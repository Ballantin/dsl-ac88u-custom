.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Convert::Binary::C 3"
.TH Convert::Binary::C 3 "2015-07-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Convert::Binary::C \- Binary Data Conversion using C Types
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Simple"
.IX Subsection "Simple"
.Vb 1
\&  use Convert::Binary::C;
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # Create a new object and parse embedded code
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  my $c = Convert::Binary::C\->new\->parse(<<ENDC);
\&  
\&  enum Month { JAN, FEB, MAR, APR, MAY, JUN,
\&               JUL, AUG, SEP, OCT, NOV, DEC };
\&  
\&  struct Date {
\&    int        year;
\&    enum Month month;
\&    int        day;
\&  };
\&  
\&  ENDC
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # Pack Perl data structure into a binary string
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  my $date = { year => 2002, month => \*(AqDEC\*(Aq, day => 24 };
\&  
\&  my $packed = $c\->pack(\*(AqDate\*(Aq, $date);
.Ve
.SS "Advanced"
.IX Subsection "Advanced"
.Vb 2
\&  use Convert::Binary::C;
\&  use Data::Dumper;
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # Create a new object
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  my $c = new Convert::Binary::C ByteOrder => \*(AqBigEndian\*(Aq;
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # Add include paths and global preprocessor defines
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  $c\->Include(\*(Aq/usr/lib/gcc/i686\-pc\-linux\-gnu/4.5.2/include\*(Aq,
\&              \*(Aq/usr/lib/gcc/i686\-pc\-linux\-gnu/4.5.2/include\-fixed\*(Aq,
\&              \*(Aq/usr/include\*(Aq)
\&    \->Define(qw( _\|_USE_POSIX _\|_USE_ISOC99=1 ));
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # Parse the \*(Aqtime.h\*(Aq header file
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  $c\->parse_file(\*(Aqtime.h\*(Aq);
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # See which files the object depends on
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  print Dumper([$c\->dependencies]);
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # See if struct timespec is defined and dump its definition
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  if ($c\->def(\*(Aqstruct timespec\*(Aq)) {
\&    print Dumper($c\->struct(\*(Aqtimespec\*(Aq));
\&  }
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # Create some binary dummy data
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  my $data = "binary_test_string";
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # Unpack $data according to \*(Aqstruct timespec\*(Aq definition
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  if (length($data) >= $c\->sizeof(\*(Aqtimespec\*(Aq)) {
\&    my $perl = $c\->unpack(\*(Aqtimespec\*(Aq, $data);
\&    print Dumper($perl);
\&  }
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # See which member lies at offset 5 of \*(Aqstruct timespec\*(Aq
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  my $member = $c\->member(\*(Aqtimespec\*(Aq, 5);
\&  print "member(\*(Aqtimespec\*(Aq, 5) = \*(Aq$member\*(Aq\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Convert::Binary::C is a preprocessor and parser for C type
definitions. It is highly configurable and supports
arbitrarily complex data structures. Its object-oriented
interface has \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR methods
that act as replacements for
Perl's \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR and
allow to use C types instead of a string representation
of the data structure for conversion of binary data from and
to Perl's complex data structures.
.PP
Actually, what Convert::Binary::C does is not very different
from what a C compiler does, just that it doesn't compile the
source code into an object file or executable, but only parses
the code and allows Perl to use the enumerations, structs, unions
and typedefs that have been defined within your C source for binary
data conversion, similar to
Perl's \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR.
.PP
Beyond that, the module offers a lot of convenience methods
to retrieve information about the C types that have been parsed.
.SS "Background and History"
.IX Subsection "Background and History"
In late 2000 I wrote a real-time debugging interface for an
embedded medical device that allowed me to send out data from
that device over its integrated Ethernet adapter.
The interface was \f(CW\*(C`printf()\*(C'\fR\-like, so you could easily send
out strings or numbers. But you could also send out what I
called \fIarbitrary data\fR, which was intended for arbitrary
blocks of the device's memory.
.PP
Another part of this real-time debugger was a Perl application
running on my workstation that gathered all the messages that
were sent out from the embedded device. It printed all the
strings and numbers, and hex-dumped the arbitrary data.
However, manually parsing a couple of 300 byte hex-dumps of a
complex C structure is not only frustrating, but also error-prone
and time consuming.
.PP
Using \f(CW\*(C`unpack\*(C'\fR to retrieve the contents
of a C structure works fine for small structures and if you
don't have to deal with struct member alignment. But otherwise,
maintaining such code can be as awful as deciphering hex-dumps.
.PP
As I didn't find anything to solve my problem on the \s-1CPAN,
I\s0 wrote a little module that translated simple C structs
into \f(CW\*(C`unpack\*(C'\fR strings. It worked, but
it was slow. And since it couldn't deal with struct member
alignment, I soon found myself adding padding bytes everywhere.
So again, I had to maintain two sources, and changing one of
them forced me to touch the other one.
.PP
All in all, this little module seemed to make my task a bit
easier, but it was far from being what I was thinking of:
.IP "\(bu" 2
A module that could directly use the source I've been coding
for the embedded device without any modifications.
.IP "\(bu" 2
A module that could be configured to match the properties
of the different compilers and target platforms I was using.
.IP "\(bu" 2
A module that was fast enough to decode a great amount of
binary data even on my slow workstation.
.PP
I didn't know how to accomplish these tasks until I read something
about \s-1XS.\s0 At least, it seemed as if it could solve my performance
problems. However, writing a C parser in C isn't easier than it is
in Perl. But writing a C preprocessor from scratch is even worse.
.PP
Fortunately enough, after a few weeks of searching I found both,
a lean, open-source C preprocessor library, and a reusable \s-1YACC\s0
grammar for ANSI-C. That was the beginning of the development of
Convert::Binary::C in late 2001.
.PP
Now, I'm successfully using the module in my embedded environment
since long before it appeared on \s-1CPAN.\s0 From my point of view, it
is exactly what I had in mind. It's fast, flexible, easy to use
and portable. It doesn't require external programs or other Perl
modules.
.SS "About this document"
.IX Subsection "About this document"
This document describes how to use Convert::Binary::C. A lot of
different features are presented, and the example code sometimes
uses Perl's more advanced language elements. If your experience
with Perl is rather limited, you should know how to use Perl's
very good documentation system.
.PP
To look up one of the manpages, use the \f(CW\*(C`perldoc\*(C'\fR command.
For example,
.PP
.Vb 1
\&  perldoc perl
.Ve
.PP
will show you Perl's main manpage. To look up a specific Perl
function, use \f(CW\*(C`perldoc \-f\*(C'\fR:
.PP
.Vb 1
\&  perldoc \-f map
.Ve
.PP
gives you more information about the \f(CW\*(C`map\*(C'\fR function.
You can also search the \s-1FAQ\s0 using \f(CW\*(C`perldoc \-q\*(C'\fR:
.PP
.Vb 1
\&  perldoc \-q array
.Ve
.PP
will give you everything you ever wanted to know about Perl
arrays. But now, let's go on with some real stuff!
.SS "Why use Convert::Binary::C?"
.IX Subsection "Why use Convert::Binary::C?"
Say you want to pack (or unpack) data according to the following
C structure:
.PP
.Vb 5
\&  struct foo {
\&    char ary[3];
\&    unsigned short baz;
\&    int bar;
\&  };
.Ve
.PP
You could of course use
Perl's \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR functions:
.PP
.Vb 4
\&  @ary = (1, 2, 3);
\&  $baz = 40000;
\&  $bar = \-4711;
\&  $binary = pack \*(Aqc3 S i\*(Aq, @ary, $baz, $bar;
.Ve
.PP
But this implies that the struct members are byte aligned. If
they were long aligned (which is the default for most compilers),
you'd have to write
.PP
.Vb 1
\&  $binary = pack \*(Aqc3 x S x2 i\*(Aq, @ary, $baz, $bar;
.Ve
.PP
which doesn't really increase readability.
.PP
Now imagine that you need to pack the data for a completely
different architecture with different byte order. You would
look into the \f(CW\*(C`pack\*(C'\fR manpage again and
perhaps come up with this:
.PP
.Vb 1
\&  $binary = pack \*(Aqc3 x n x2 N\*(Aq, @ary, $baz, $bar;
.Ve
.PP
However, if you try to unpack \f(CW$foo\fR again, your signed values
have turned into unsigned ones.
.PP
All this can still be managed with Perl. But imagine your
structures get more complex? Imagine you need to support
different platforms? Imagine you need to make changes to
the structures? You'll not only have to change the C source
but also dozens of \f(CW\*(C`pack\*(C'\fR strings in
your Perl code. This is no fun. And Perl should be fun.
.PP
Now, wouldn't it be great if you could just read in the C
source you've already written and use all the types defined
there for packing and unpacking? That's what Convert::Binary::C
does.
.SS "Creating a Convert::Binary::C object"
.IX Subsection "Creating a Convert::Binary::C object"
To use Convert::Binary::C just say
.PP
.Vb 1
\&  use Convert::Binary::C;
.Ve
.PP
to load the module. Its interface is completely object
oriented, so it doesn't export any functions.
.PP
Next, you need to create a new Convert::Binary::C object. This
can be done by either
.PP
.Vb 1
\&  $c = Convert::Binary::C\->new;
.Ve
.PP
or
.PP
.Vb 1
\&  $c = new Convert::Binary::C;
.Ve
.PP
You can optionally pass configuration options to
the constructor as described in the next section.
.SS "Configuring the object"
.IX Subsection "Configuring the object"
To configure a Convert::Binary::C object, you can either call
the \f(CW\*(C`configure\*(C'\fR method or directly pass the configuration
options to the constructor. If you want to change byte order
and alignment, you can use
.PP
.Vb 2
\&  $c\->configure(ByteOrder => \*(AqLittleEndian\*(Aq,
\&                Alignment => 2);
.Ve
.PP
or you can change the construction code to
.PP
.Vb 2
\&  $c = new Convert::Binary::C ByteOrder => \*(AqLittleEndian\*(Aq,
\&                              Alignment => 2;
.Ve
.PP
Either way, the object will now know that it should use
little endian (Intel) byte order and 2\-byte struct member
alignment for packing and unpacking.
.PP
Alternatively, you can use the option names as names of
methods to configure the object, like:
.PP
.Vb 1
\&  $c\->ByteOrder(\*(AqLittleEndian\*(Aq);
.Ve
.PP
You can also retrieve information about the current
configuration of a Convert::Binary::C object. For details,
see the section about the \f(CW\*(C`configure\*(C'\fR method.
.SS "Parsing C code"
.IX Subsection "Parsing C code"
Convert::Binary::C allows two ways of parsing C source. Either
by parsing external C header or C source files:
.PP
.Vb 1
\&  $c\->parse_file(\*(Aqheader.h\*(Aq);
.Ve
.PP
Or by parsing C code embedded in your script:
.PP
.Vb 7
\&  $c\->parse(<<\*(AqCCODE\*(Aq);
\&  struct foo {
\&    char ary[3];
\&    unsigned short baz;
\&    int bar;
\&  };
\&  CCODE
.Ve
.PP
Now the object \f(CW$c\fR will know everything about \f(CW\*(C`struct foo\*(C'\fR.
The example above uses a so-called here-document. It allows one to
easily embed multi-line strings in your code. You can find more
about here-documents in perldata or perlop.
.PP
Since the \f(CW\*(C`parse\*(C'\fR and \f(CW\*(C`parse_file\*(C'\fR methods
throw an exception when a parse error occurs, you usually want to catch
these in an \f(CW\*(C`eval\*(C'\fR block:
.PP
.Vb 4
\&  eval { $c\->parse_file(\*(Aqheader.h\*(Aq) };
\&  if ($@) {
\&    # handle error appropriately
\&  }
.Ve
.PP
Perl's special \f(CW$@\fR variable will contain an empty string (which
evaluates to a false value in boolean context) on success or
an error string on failure.
.PP
As another feature, \f(CW\*(C`parse\*(C'\fR and \f(CW\*(C`parse_file\*(C'\fR return
a reference to their object on success, just like \f(CW\*(C`configure\*(C'\fR does
when you're configuring the object. This will allow you to write constructs
like this:
.PP
.Vb 7
\&  my $c = eval {
\&    Convert::Binary::C\->new(Include => [\*(Aq/usr/include\*(Aq])
\&                      \->parse_file(\*(Aqheader.h\*(Aq)
\&  };
\&  if ($@) {
\&    # handle error appropriately
\&  }
.Ve
.SS "Packing and unpacking"
.IX Subsection "Packing and unpacking"
Convert::Binary::C has two methods, \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR,
that act similar to the functions of same denominator in Perl.
To perform the packing described in the example above,
you could write:
.PP
.Vb 6
\&  $data = {
\&    ary => [1, 2, 3],
\&    baz => 40000,
\&    bar => \-4711,
\&  };
\&  $binary = $c\->pack(\*(Aqfoo\*(Aq, $data);
.Ve
.PP
Unpacking will work exactly the same way, just that
the \f(CW\*(C`unpack\*(C'\fR method will take a byte string as its input
and will return a reference to a (possibly very complex)
Perl data structure.
.PP
.Vb 2
\&  $binary = get_data_from_memory();
\&  $data = $c\->unpack(\*(Aqfoo\*(Aq, $binary);
.Ve
.PP
You can now easily access all of the values:
.PP
.Vb 1
\&  print "foo.ary[1] = $data\->{ary}[1]\en";
.Ve
.PP
Or you can even more conveniently use
the Data::Dumper module:
.PP
.Vb 2
\&  use Data::Dumper;
\&  print Dumper($data);
.Ve
.PP
The output would look something like this:
.PP
.Vb 9
\&  $VAR1 = {
\&    \*(Aqbar\*(Aq => \-271,
\&    \*(Aqbaz\*(Aq => 5000,
\&    \*(Aqary\*(Aq => [
\&      42,
\&      48,
\&      100
\&    ]
\&  };
.Ve
.SS "Preprocessor configuration"
.IX Subsection "Preprocessor configuration"
Convert::Binary::C uses Thomas Pornin's \f(CW\*(C`ucpp\*(C'\fR as an internal
C preprocessor. It is compliant to \s-1ISO\-C99,\s0 so you don't have
to worry about using even weird preprocessor constructs in
your code.
.PP
If your C source contains includes or depends upon preprocessor
defines, you may need to configure the internal preprocessor.
Use the \f(CW\*(C`Include\*(C'\fR and \f(CW\*(C`Define\*(C'\fR configuration options for that:
.PP
.Vb 3
\&  $c\->configure(Include => [\*(Aq/usr/include\*(Aq,
\&                            \*(Aq/home/mhx/include\*(Aq],
\&                Define  => [qw( NDEBUG FOO=42 )]);
.Ve
.PP
If your code uses system includes, it is most likely
that you will need to define the symbols that are usually
defined by the compiler.
.PP
On some operating systems, the system includes require the
preprocessor to predefine a certain set of assertions.
Assertions are supported by \f(CW\*(C`ucpp\*(C'\fR, and you can define them
either in the source code using \f(CW\*(C`#assert\*(C'\fR or as a property
of the Convert::Binary::C object using \f(CW\*(C`Assert\*(C'\fR:
.PP
.Vb 1
\&  $c\->configure(Assert => [\*(Aqpredicate(answer)\*(Aq]);
.Ve
.PP
Information about defined macros can be retrieved from the
preprocessor as long as its configuration isn't changed. The
preprocessor is implicitly reset if you change one of the
following configuration options:
.PP
.Vb 5
\&  Include
\&  Define
\&  Assert
\&  HasCPPComments
\&  HasMacroVAARGS
.Ve
.SS "Supported pragma directives"
.IX Subsection "Supported pragma directives"
Convert::Binary::C supports the \f(CW\*(C`pack\*(C'\fR pragma to locally override
struct member alignment. The supported syntax is as follows:
.IP "#pragma pack( \s-1ALIGN \s0)" 4
.IX Item "#pragma pack( ALIGN )"
Sets the new alignment to \s-1ALIGN.\s0 If \s-1ALIGN\s0 is 0, resets the
alignment to its original value.
.IP "#pragma pack" 4
.IX Item "#pragma pack"
Resets the alignment to its original value.
.IP "#pragma pack( push, \s-1ALIGN \s0)" 4
.IX Item "#pragma pack( push, ALIGN )"
Saves the current alignment on a stack and sets the new
alignment to \s-1ALIGN.\s0 If \s-1ALIGN\s0 is 0, sets the alignment to
the default alignment.
.IP "#pragma pack( pop )" 4
.IX Item "#pragma pack( pop )"
Restores the alignment to the last value saved on the
stack.
.PP
.Vb 1
\&  /*  Example assumes sizeof( short ) == 2, sizeof( long ) == 4.  */
\&  
\&  #pragma pack(1)
\&  
\&  struct nopad {
\&    char a;               /* no padding bytes between \*(Aqa\*(Aq and \*(Aqb\*(Aq */
\&    long b;
\&  };
\&  
\&  #pragma pack            /* reset to "native" alignment          */
\&  
\&  #pragma pack( push, 2 )
\&  
\&  struct pad {
\&    char    a;            /* one padding byte between \*(Aqa\*(Aq and \*(Aqb\*(Aq */
\&    long    b;
\&  
\&  #pragma pack( push, 1 )
\&  
\&    struct {
\&      char  c;            /* no padding between \*(Aqc\*(Aq and \*(Aqd\*(Aq       */
\&      short d;
\&    }       e;            /* sizeof( e ) == 3                     */
\&  
\&  #pragma pack( pop );    /* back to pack( 2 )                    */
\&  
\&    long    f;            /* one padding byte between \*(Aqe\*(Aq and \*(Aqf\*(Aq */
\&  };
\&  
\&  #pragma pack( pop );    /* back to "native"                     */
.Ve
.PP
The \f(CW\*(C`pack\*(C'\fR pragma as it is currently implemented only affects
the \fImaximum\fR struct member alignment. There are compilers
that also allow to specify the \fIminimum\fR struct member
alignment. This is not supported by Convert::Binary::C.
.ie n .SS "Automatic configuration using ""ccconfig"""
.el .SS "Automatic configuration using \f(CWccconfig\fP"
.IX Subsection "Automatic configuration using ccconfig"
As there are over 20 different configuration options, setting
all of them correctly can be a lengthy and tedious task.
.PP
The \f(CW\*(C`ccconfig\*(C'\fR script, which is bundled with this
module, aims at automatically determining the correct compiler
configuration by testing the compiler executable. It works for
both, native and cross compilers.
.SH "UNDERSTANDING TYPES"
.IX Header "UNDERSTANDING TYPES"
This section covers one of the fundamental features of
Convert::Binary::C. It's how \fItype expressions\fR, referred to
as TYPEs in the method reference, are handled
by the module.
.PP
Many of the methods,
namely \f(CW\*(C`pack\*(C'\fR, \f(CW\*(C`unpack\*(C'\fR, \f(CW\*(C`sizeof\*(C'\fR, \f(CW\*(C`typeof\*(C'\fR, \f(CW\*(C`member\*(C'\fR, \f(CW\*(C`offsetof\*(C'\fR, \f(CW\*(C`def\*(C'\fR, \f(CW\*(C`initializer\*(C'\fR and \f(CW\*(C`tag\*(C'\fR,
are passed a \s-1TYPE\s0 to operate on as their first argument.
.SS "Standard Types"
.IX Subsection "Standard Types"
These are trivial. Standard types are simply enum names, struct
names, union names, or typedefs. Almost every method that wants
a \s-1TYPE\s0 will accept a standard type.
.PP
For enums, structs and unions, the prefixes \f(CW\*(C`enum\*(C'\fR, \f(CW\*(C`struct\*(C'\fR and \f(CW\*(C`union\*(C'\fR are
optional. However, if a typedef with the same name exists, like in
.PP
.Vb 3
\&  struct foo {
\&    int bar;
\&  };
\&  
\&  typedef int foo;
.Ve
.PP
you will have to use the prefix to distinguish between the
struct and the typedef. Otherwise, a typedef is always given
preference.
.SS "Basic Types"
.IX Subsection "Basic Types"
Basic types, or atomic types, are \f(CW\*(C`int\*(C'\fR or \f(CW\*(C`char\*(C'\fR, for example.
It's possible to use these basic types without having parsed any
code. You can simply do
.PP
.Vb 3
\&  $c = new Convert::Binary::C;
\&  $size = $c\->sizeof(\*(Aqunsigned long\*(Aq);
\&  $data = $c\->pack(\*(Aqshort int\*(Aq, 42);
.Ve
.PP
Even though the above works fine, it is not possible to define
more complex types on the fly, so
.PP
.Vb 1
\&  $size = $c\->sizeof(\*(Aqstruct { int a, b; }\*(Aq);
.Ve
.PP
will result in an error.
.PP
Basic types are not supported by all methods. For example, it makes
no sense to use \f(CW\*(C`member\*(C'\fR or \f(CW\*(C`offsetof\*(C'\fR on
a basic type. Using \f(CW\*(C`typeof\*(C'\fR isn't very useful, but
supported.
.SS "Member Expressions"
.IX Subsection "Member Expressions"
This is by far the most complex part, depending on the complexity of
your data structures. Any standard type that
defines a compound or an array may be followed by a member expression
to select only a certain part of the data type. Say you have parsed the
following C code:
.PP
.Vb 6
\&  struct foo {
\&    long type;
\&    struct {
\&      short x, y;
\&    } array[20];
\&  };
\&  
\&  typedef struct foo matrix[8][8];
.Ve
.PP
You may want to know the size of the \f(CW\*(C`array\*(C'\fR member of \f(CW\*(C`struct foo\*(C'\fR.
This is quite easy:
.PP
.Vb 1
\&  print $c\->sizeof(\*(Aqfoo.array\*(Aq), " bytes";
.Ve
.PP
will print
.PP
.Vb 1
\&  80 bytes
.Ve
.PP
depending of course on the \f(CW\*(C`ShortSize\*(C'\fR you configured.
.PP
If you wanted to unpack only a single column of \f(CW\*(C`matrix\*(C'\fR, that's
easy as well (and of course it doesn't matter which index you use):
.PP
.Vb 1
\&  $column = $c\->unpack(\*(Aqmatrix[2]\*(Aq, $data);
.Ve
.PP
Just like in C, it is possible to use out-of-bounds array indices.
This means that, for example, despite \f(CW\*(C`array\*(C'\fR is declared to have
20 elements, the following code
.PP
.Vb 2
\&  $size   = $c\->sizeof(\*(Aqfoo.array[4711]\*(Aq);
\&  $offset = $c\->offsetof(\*(Aqfoo\*(Aq, \*(Aqarray[\-13]\*(Aq);
.Ve
.PP
is perfectly valid and will result in:
.PP
.Vb 2
\&  $size   = 4
\&  $offset = \-48
.Ve
.PP
Member expressions can be arbitrarily complex:
.PP
.Vb 2
\&  $type = $c\->typeof(\*(Aqmatrix[2][3].array[7].y\*(Aq);
\&  print "the type is $type";
.Ve
.PP
will, for example, print
.PP
.Vb 1
\&  the type is short
.Ve
.PP
Member expressions are also used as the second argument
to \f(CW\*(C`offsetof\*(C'\fR.
.SS "Offsets"
.IX Subsection "Offsets"
Members returned by the \f(CW\*(C`member\*(C'\fR method have an optional
offset suffix to indicate that the given offset doesn't point to the
start of that member. For example,
.PP
.Vb 2
\&  $member = $c\->member(\*(Aqmatrix\*(Aq, 1431);
\&  print $member;
.Ve
.PP
will print
.PP
.Vb 1
\&  [2][1].type+3
.Ve
.PP
If you would use this as a member expression, like in
.PP
.Vb 1
\&  $size = $c\->sizeof("matrix $member");
.Ve
.PP
the offset suffix will simply be ignored. Actually, it will be
ignored for all methods if it's used in the first argument.
.PP
When used in the second argument to \f(CW\*(C`offsetof\*(C'\fR,
it will usually do what you mean, i. e. the offset suffix, if
present, will be considered when determining the offset. This
behaviour ensures that
.PP
.Vb 3
\&  $member = $c\->member(\*(Aqfoo\*(Aq, 43);
\&  $offset = $c\->offsetof(\*(Aqfoo\*(Aq, $member);
\&  print "\*(Aq$member\*(Aq is located at offset $offset of struct foo";
.Ve
.PP
will always correctly set \f(CW$offset\fR:
.PP
.Vb 1
\&  \*(Aq.array[9].y+1\*(Aq is located at offset 43 of struct foo
.Ve
.PP
If this is not what you mean, e.g. because you want to know the
offset where the member returned by \f(CW\*(C`member\*(C'\fR starts,
you just have to remove the suffix:
.PP
.Vb 3
\&  $member =~ s/\e+\ed+$//;
\&  $offset = $c\->offsetof(\*(Aqfoo\*(Aq, $member);
\&  print "\*(Aq$member\*(Aq starts at offset $offset of struct foo";
.Ve
.PP
This would then print:
.PP
.Vb 1
\&  \*(Aq.array[9].y\*(Aq starts at offset 42 of struct foo
.Ve
.SH "USING TAGS"
.IX Header "USING TAGS"
In a nutshell, tags are properties that you can attach to types.
.PP
You can add tags to types using the \f(CW\*(C`tag\*(C'\fR method,
and remove them using \f(CW\*(C`tag\*(C'\fR or \f(CW\*(C`untag\*(C'\fR,
for example:
.PP
.Vb 2
\&  # Attach \*(AqFormat\*(Aq and \*(AqHooks\*(Aq tags
\&  $c\->tag(\*(Aqtype\*(Aq, Format => \*(AqString\*(Aq, Hooks => { pack => \e&rout });
\&  
\&  $c\->untag(\*(Aqtype\*(Aq, \*(AqFormat\*(Aq);  # Remove only \*(AqFormat\*(Aq tag
\&  $c\->untag(\*(Aqtype\*(Aq);            # Remove all tags
.Ve
.PP
You can also use \f(CW\*(C`tag\*(C'\fR to see which tags are
attached to a type, for example:
.PP
.Vb 1
\&  $tags = $c\->tag(\*(Aqtype\*(Aq);
.Ve
.PP
This would give you:
.PP
.Vb 6
\&  $tags = {
\&    \*(AqHooks\*(Aq => {
\&      \*(Aqpack\*(Aq => \e&rout
\&    },
\&    \*(AqFormat\*(Aq => \*(AqString\*(Aq
\&  };
.Ve
.PP
Currently, there are only a couple of different tags that
influence the way data is packed and unpacked. There are
probably more tags to come in the future.
.SS "The Format Tag"
.IX Subsection "The Format Tag"
One of the tags currently available is the \f(CW\*(C`Format\*(C'\fR tag.
Using this tag, you can tell a Convert::Binary::C object to
pack and unpack a certain data type in a special way.
.PP
For example, if you have a (fixed length) string type
.PP
.Vb 1
\&  typedef char str_type[40];
.Ve
.PP
this type would, by default, be unpacked as an array
of \f(CW\*(C`char\*(C'\fRs. That's because it \fBis\fR only an array
of \f(CW\*(C`char\*(C'\fRs, and Convert::Binary::C doesn't know it is
actually used as a string.
.PP
But you can tell Convert::Binary::C that \f(CW\*(C`str_type\*(C'\fR is
a C string using the \f(CW\*(C`Format\*(C'\fR tag:
.PP
.Vb 1
\&  $c\->tag(\*(Aqstr_type\*(Aq, Format => \*(AqString\*(Aq);
.Ve
.PP
This will make \f(CW\*(C`unpack\*(C'\fR (and of course
also \f(CW\*(C`pack\*(C'\fR) treat the binary data like a
null-terminated C string:
.PP
.Vb 3
\&  $binary = "Hello World!\en\e0 this is just some dummy data";
\&  $hello = $c\->unpack(\*(Aqstr_type\*(Aq, $binary);
\&  print $hello;
.Ve
.PP
would thusly print:
.PP
.Vb 1
\&  Hello World!
.Ve
.PP
Of course, this also works the other way round:
.PP
.Vb 1
\&  use Data::Hexdumper;
\&  
\&  $binary = $c\->pack(\*(Aqstr_type\*(Aq, "Just another C::B::C hacker");
\&  print hexdump(data => $binary);
.Ve
.PP
would print:
.PP
.Vb 3
\&    0x0000 : 4A 75 73 74 20 61 6E 6F 74 68 65 72 20 43 3A 3A : Just.another.C::
\&    0x0010 : 42 3A 3A 43 20 68 61 63 6B 65 72 00 00 00 00 00 : B::C.hacker.....
\&    0x0020 : 00 00 00 00 00 00 00 00                         : ........
.Ve
.PP
If you want Convert::Binary::C to not interpret the binary
data at all, you can set the \f(CW\*(C`Format\*(C'\fR tag to \f(CW\*(C`Binary\*(C'\fR.
This might not be seem very useful,
as \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR would
just pass through the unmodified binary data.
But you can tag not only whole types, but also compound
members. For example
.PP
.Vb 7
\&  $c\->parse(<<ENDC);
\&  struct packet {
\&    unsigned short header;
\&    unsigned short flags;
\&    unsigned char  payload[28];
\&  };
\&  ENDC
\&  
\&  $c\->tag(\*(Aqpacket.payload\*(Aq, Format => \*(AqBinary\*(Aq);
.Ve
.PP
would allow you to write:
.PP
.Vb 1
\&  read FILE, $payload, $c\->sizeof(\*(Aqpacket.payload\*(Aq);
\&  
\&  $packet = {
\&              header  => 4711,
\&              flags   => 0xf00f,
\&              payload => $payload,
\&            };
\&  
\&  $binary = $c\->pack(\*(Aqpacket\*(Aq, $packet);
\&  
\&  print hexdump(data => $binary);
.Ve
.PP
This would print something like:
.PP
.Vb 2
\&    0x0000 : 12 67 F0 0F 6E 6F 0A 6E 6F 0A 6E 6F 0A 6E 6F 0A : .g..no.no.no.no.
\&    0x0010 : 6E 6F 0A 6E 6F 0A 6E 6F 0A 6E 6F 0A 6E 6F 0A 6E : no.no.no.no.no.n
.Ve
.PP
For obvious reasons, it is not allowed to attach a \f(CW\*(C`Format\*(C'\fR tag
to bitfield members. Trying to do so will result in an exception
being thrown by the \f(CW\*(C`tag\*(C'\fR method.
.SS "The ByteOrder Tag"
.IX Subsection "The ByteOrder Tag"
The \f(CW\*(C`ByteOrder\*(C'\fR tag allows you to override the byte order of
certain types or members. The implementation of this tag is
considered \fBexperimental\fR and may be subject to changes in the
future.
.PP
Usually it doesn't make much sense to override the byte order,
but there may be applications where a sub-structure is packed
in a different byte order than the surrounding structure.
.PP
Take, for example, the following code:
.PP
.Vb 3
\&  $c = Convert::Binary::C\->new(ByteOrder => \*(AqBigEndian\*(Aq,
\&                               OrderMembers => 1);
\&  $c\->parse(<<\*(AqENDC\*(Aq);
\&  
\&  typedef unsigned short u_16;
\&  
\&  struct coords_3d {
\&    long x, y, z;
\&  };
\&  
\&  struct coords_msg {
\&    u_16 header;
\&    u_16 length;
\&    struct coords_3d coords;
\&  };
\&  
\&  ENDC
.Ve
.PP
Assume that while \f(CW\*(C`coords_msg\*(C'\fR is big endian, the embedded
coordinates \f(CW\*(C`coords_3d\*(C'\fR are stored in little endian format
for some reason. In C, you'll have to handle this manually.
.PP
But using Convert::Binary::C, you can simply attach
a \f(CW\*(C`ByteOrder\*(C'\fR tag to either the \f(CW\*(C`coords_3d\*(C'\fR structure or to
the \f(CW\*(C`coords\*(C'\fR member of the \f(CW\*(C`coords_msg\*(C'\fR structure. Both
will work in this case. The only difference is that if you
tag the \f(CW\*(C`coords\*(C'\fR member, \f(CW\*(C`coords_3d\*(C'\fR will only be treated
as little endian if you \f(CW\*(C`pack\*(C'\fR or \f(CW\*(C`unpack\*(C'\fR the
\&\f(CW\*(C`coords_msg\*(C'\fR structure. (\s-1BTW,\s0 you could also tag all members
of \f(CW\*(C`coords_3d\*(C'\fR individually, but that would be inefficient.)
.PP
So, let's attach the \f(CW\*(C`ByteOrder\*(C'\fR tag to the \f(CW\*(C`coords\*(C'\fR member:
.PP
.Vb 1
\&  $c\->tag(\*(Aqcoords_msg.coords\*(Aq, ByteOrder => \*(AqLittleEndian\*(Aq);
.Ve
.PP
Assume the following binary message:
.PP
.Vb 1
\&    0x0000 : 00 2A 00 0C FF FF FF FF 02 00 00 00 2A 00 00 00 : .*..........*...
.Ve
.PP
If you unpack this message...
.PP
.Vb 1
\&  $msg = $c\->unpack(\*(Aqcoords_msg\*(Aq, $binary);
.Ve
.PP
\&...you will get the following data structure:
.PP
.Vb 9
\&  $msg = {
\&    \*(Aqheader\*(Aq => 42,
\&    \*(Aqlength\*(Aq => 12,
\&    \*(Aqcoords\*(Aq => {
\&      \*(Aqx\*(Aq => \-1,
\&      \*(Aqy\*(Aq => 2,
\&      \*(Aqz\*(Aq => 42
\&    }
\&  };
.Ve
.PP
Without the \f(CW\*(C`ByteOrder\*(C'\fR tag, you would get:
.PP
.Vb 9
\&  $msg = {
\&    \*(Aqheader\*(Aq => 42,
\&    \*(Aqlength\*(Aq => 12,
\&    \*(Aqcoords\*(Aq => {
\&      \*(Aqx\*(Aq => \-1,
\&      \*(Aqy\*(Aq => 33554432,
\&      \*(Aqz\*(Aq => 704643072
\&    }
\&  };
.Ve
.PP
The \f(CW\*(C`ByteOrder\*(C'\fR tag is a \fIrecursive\fR tag, i.e. it applies
to all children of the tagged object recursively. Of course,
it is also possible to override a \f(CW\*(C`ByteOrder\*(C'\fR tag by attaching
another \f(CW\*(C`ByteOrder\*(C'\fR tag to a child type. Confused? Here's an
example. In addition to tagging the \f(CW\*(C`coords\*(C'\fR member as little
endian, we now tag \f(CW\*(C`coords_3d.y\*(C'\fR as big endian:
.PP
.Vb 2
\&  $c\->tag(\*(Aqcoords_3d.y\*(Aq, ByteOrder => \*(AqBigEndian\*(Aq);
\&  $msg = $c\->unpack(\*(Aqcoords_msg\*(Aq, $binary);
.Ve
.PP
This will return the following data structure:
.PP
.Vb 9
\&  $msg = {
\&    \*(Aqheader\*(Aq => 42,
\&    \*(Aqlength\*(Aq => 12,
\&    \*(Aqcoords\*(Aq => {
\&      \*(Aqx\*(Aq => \-1,
\&      \*(Aqy\*(Aq => 33554432,
\&      \*(Aqz\*(Aq => 42
\&    }
\&  };
.Ve
.PP
Note that if you tag both a type and a member of that type
within a compound, the tag attached to the type itself has
higher precedence. Using the example above, if you would attach
a \f(CW\*(C`ByteOrder\*(C'\fR tag to both \f(CW\*(C`coords_msg.coords\*(C'\fR and \f(CW\*(C`coords_3d\*(C'\fR,
the tag attached to \f(CW\*(C`coords_3d\*(C'\fR would always win.
.PP
Also note that the \f(CW\*(C`ByteOrder\*(C'\fR tag might not work as expected
along with bitfields, which is why the implementation is considered
experimental. Bitfields are currently \fBnot\fR affected by
the \f(CW\*(C`ByteOrder\*(C'\fR tag at all. This is because the byte order
would affect the bitfield layout, and a consistent implementation
supporting multiple layouts of the same struct would be quite
bulky and probably slow down the whole module.
.PP
If you really need the correct behaviour, you can use the
following trick:
.PP
.Vb 1
\&  $le = Convert::Binary::C\->new(ByteOrder => \*(AqLittleEndian\*(Aq);
\&  
\&  $le\->parse(<<\*(AqENDC\*(Aq);
\&  
\&  typedef unsigned short u_16;
\&  typedef unsigned long  u_32;
\&  
\&  struct message {
\&    u_16 header;
\&    u_16 length;
\&    struct {
\&      u_32 a;
\&      u_32 b;
\&      u_32 c :  7;
\&      u_32 d :  5;
\&      u_32 e : 20;
\&    } data;
\&  };
\&  
\&  ENDC
\&  
\&  $be = $le\->clone\->ByteOrder(\*(AqBigEndian\*(Aq);
\&  
\&  $le\->tag(\*(Aqmessage.data\*(Aq, Format => \*(AqBinary\*(Aq, Hooks => {
\&      unpack => sub { $be\->unpack(\*(Aqmessage.data\*(Aq, @_) },
\&      pack   => sub { $be\->pack(\*(Aqmessage.data\*(Aq, @_) },
\&    });
\&  
\&  
\&  $msg = $le\->unpack(\*(Aqmessage\*(Aq, $binary);
.Ve
.PP
This uses the \f(CW\*(C`Format\*(C'\fR and \f(CW\*(C`Hooks\*(C'\fR tags
along with a big endian \f(CW\*(C`clone\*(C'\fR of the original
little endian object. It attaches hooks to the little endian
object and in the hooks it uses the big endian object
to \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR the binary data.
.SS "The Dimension Tag"
.IX Subsection "The Dimension Tag"
The \f(CW\*(C`Dimension\*(C'\fR tag allows you to override the declared dimension
of an array for packing or unpacking data. The implementation of
this tag is considered \fBvery experimental\fR and will \fBdefinitely change\fR in
a future release.
.PP
That being said, the \f(CW\*(C`Dimension\*(C'\fR tag is primarily useful to support
variable length arrays. Usually, you have to write the following code
for such a variable length array in C:
.PP
.Vb 5
\&  struct c_message
\&  {
\&    unsigned count;
\&    char data[1];
\&  };
.Ve
.PP
So, because you cannot declare an empty array, you declare an array
with a single element. If you have a \s-1ISO\-C99\s0 compliant compiler,
you can write this code instead:
.PP
.Vb 5
\&  struct c99_message
\&  {
\&    unsigned count;
\&    char data[];
\&  };
.Ve
.PP
This explicitly tells the compiler that \f(CW\*(C`data\*(C'\fR is a flexible array
member. Convert::Binary::C already uses this information to
handle flexible array members in
a special way.
.PP
As you can see in the following example, the two types are treated
differently:
.PP
.Vb 3
\&  $data = pack \*(AqNC*\*(Aq, 3, 1..8;
\&  $uc   = $c\->unpack(\*(Aqc_message\*(Aq, $data);
\&  $uc99 = $c\->unpack(\*(Aqc99_message\*(Aq, $data);
.Ve
.PP
This will result in:
.PP
.Vb 2
\&  $uc = {\*(Aqcount\*(Aq => 3,\*(Aqdata\*(Aq => [1]};
\&  $uc99 = {\*(Aqcount\*(Aq => 3,\*(Aqdata\*(Aq => [1,2,3,4,5,6,7,8]};
.Ve
.PP
However, only few compilers support \s-1ISO\-C99,\s0 and you probably don't want
to change your existing code only to get some extra features when
using Convert::Binary::C.
.PP
So it is possible to attach a tag to the \f(CW\*(C`data\*(C'\fR member of
the \f(CW\*(C`c_message\*(C'\fR struct that tells Convert::Binary::C to treat
the array as if it were flexible:
.PP
.Vb 1
\&  $c\->tag(\*(Aqc_message.data\*(Aq, Dimension => \*(Aq*\*(Aq);
.Ve
.PP
Now both \f(CW\*(C`c_message\*(C'\fR and \f(CW\*(C`c99_message\*(C'\fR will behave exactly the
same when using \f(CW\*(C`pack\*(C'\fR or \f(CW\*(C`unpack\*(C'\fR.
Repeating the above code:
.PP
.Vb 1
\&  $uc = $c\->unpack(\*(Aqc_message\*(Aq, $data);
.Ve
.PP
This will result in:
.PP
.Vb 1
\&  $uc = {\*(Aqcount\*(Aq => 3,\*(Aqdata\*(Aq => [1,2,3,4,5,6,7,8]};
.Ve
.PP
But there's more you can do. Even though it probably doesn't
make much sense, you can tag a fixed dimension to an array:
.PP
.Vb 1
\&  $c\->tag(\*(Aqc_message.data\*(Aq, Dimension => \*(Aq5\*(Aq);
.Ve
.PP
This will obviously result in:
.PP
.Vb 1
\&  $uc = {\*(Aqcount\*(Aq => 3,\*(Aqdata\*(Aq => [1,2,3,4,5]};
.Ve
.PP
A more useful way to use the \f(CW\*(C`Dimension\*(C'\fR tag is to set it to
the name of a member in the same compound:
.PP
.Vb 1
\&  $c\->tag(\*(Aqc_message.data\*(Aq, Dimension => \*(Aqcount\*(Aq);
.Ve
.PP
Convert::Binary::C will now use the value of that member to
determine the size of the array, so unpacking will result in:
.PP
.Vb 1
\&  $uc = {\*(Aqcount\*(Aq => 3,\*(Aqdata\*(Aq => [1,2,3]};
.Ve
.PP
Of course, you can also tag flexible array members. And yes,
it's also possible to use more complex member expressions:
.PP
.Vb 5
\&  $c\->parse(<<ENDC);
\&  struct msg_header
\&  {
\&    unsigned len[2];
\&  };
\&  
\&  struct more_complex
\&  {
\&    struct msg_header hdr;
\&    char data[];
\&  };
\&  ENDC
\&  
\&  $data = pack \*(AqNNC*\*(Aq, 42, 7, 1 .. 10;
\&  
\&  $c\->tag(\*(Aqmore_complex.data\*(Aq, Dimension => \*(Aqhdr.len[1]\*(Aq);
\&  
\&  $u = $c\->unpack(\*(Aqmore_complex\*(Aq, $data);
.Ve
.PP
The result will be:
.PP
.Vb 10
\&  $u = {
\&    \*(Aqhdr\*(Aq => {
\&      \*(Aqlen\*(Aq => [
\&        42,
\&        7
\&      ]
\&    },
\&    \*(Aqdata\*(Aq => [
\&      1,
\&      2,
\&      3,
\&      4,
\&      5,
\&      6,
\&      7
\&    ]
\&  };
.Ve
.PP
By the way, it's also possible to tag arrays that are not
embedded inside a compound:
.PP
.Vb 3
\&  $c\->parse(<<ENDC);
\&  typedef unsigned short short_array[];
\&  ENDC
\&  
\&  $c\->tag(\*(Aqshort_array\*(Aq, Dimension => \*(Aq5\*(Aq);
\&  
\&  $u = $c\->unpack(\*(Aqshort_array\*(Aq, $data);
.Ve
.PP
Resulting in:
.PP
.Vb 1
\&  $u = [0,42,0,7,258];
.Ve
.PP
The final and most powerful way to define a \f(CW\*(C`Dimension\*(C'\fR tag is
to pass it a subroutine reference. The referenced subroutine can
execute whatever code is necessary to determine the size of the
tagged array:
.PP
.Vb 5
\&  sub get_size
\&  {
\&    my $m = shift;
\&    return $m\->{hdr}{len}[0] / $m\->{hdr}{len}[1];
\&  }
\&  
\&  $c\->tag(\*(Aqmore_complex.data\*(Aq, Dimension => \e&get_size);
\&  
\&  $u = $c\->unpack(\*(Aqmore_complex\*(Aq, $data);
.Ve
.PP
As you can guess from the above code, the subroutine is being passed
a reference to hash that stores the already unpacked part of the
compound embedding the tagged array. This is the result:
.PP
.Vb 10
\&  $u = {
\&    \*(Aqhdr\*(Aq => {
\&      \*(Aqlen\*(Aq => [
\&        42,
\&        7
\&      ]
\&    },
\&    \*(Aqdata\*(Aq => [
\&      1,
\&      2,
\&      3,
\&      4,
\&      5,
\&      6
\&    ]
\&  };
.Ve
.PP
You can also pass custom arguments to the subroutines by using
the \f(CW\*(C`arg\*(C'\fR method. This is similar to the functionality
offered by the \f(CW\*(C`Hooks\*(C'\fR tag.
.PP
Of course, all that also works for the \f(CW\*(C`pack\*(C'\fR method
as well.
.PP
However, the current implementation has at least one shortcomings,
which is why it's experimental: The \f(CW\*(C`Dimension\*(C'\fR tag doesn't impact
compound layout. This means that while you can alter the size of an
array in the middle of a compound, the offset of the members after
that array won't be impacted. I'd rather like to see the layout adapt
dynamically, so this is what I'm hoping to implement in the future.
.SS "The Hooks Tag"
.IX Subsection "The Hooks Tag"
Hooks are a special kind of tag that can be extremely useful.
.PP
Using hooks, you can easily override the
way \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR handle data
using your own subroutines.
If you define hooks for a certain data type, each time this
data type is processed the corresponding hook will be called
to allow you to modify that data.
.PP
\fIBasic Hooks\fR
.IX Subsection "Basic Hooks"
.PP
Here's an example. Let's assume the following C code has been
parsed:
.PP
.Vb 3
\&  typedef unsigned long u_32;
\&  typedef u_32          ProtoId;
\&  typedef ProtoId       MyProtoId;
\&  
\&  struct MsgHeader {
\&    MyProtoId id;
\&    u_32      len;
\&  };
\&
\&  struct String {
\&    u_32 len;
\&    char buf[];
\&  };
.Ve
.PP
You could now use the types above and, for example, unpack
binary data representing a \f(CW\*(C`MsgHeader\*(C'\fR like this:
.PP
.Vb 1
\&  $msg_header = $c\->unpack(\*(AqMsgHeader\*(Aq, $data);
.Ve
.PP
This would give you:
.PP
.Vb 4
\&  $msg_header = {
\&    \*(Aqlen\*(Aq => 13,
\&    \*(Aqid\*(Aq => 42
\&  };
.Ve
.PP
Instead of dealing with \f(CW\*(C`ProtoId\*(C'\fR's as integers, you would
rather like to have them as clear text. You could provide
subroutines to convert between clear text and integers:
.PP
.Vb 5
\&  %proto = (
\&    CATS      =>    1,
\&    DOGS      =>   42,
\&    HEDGEHOGS => 4711,
\&  );
\&  
\&  %rproto = reverse %proto;
\&  
\&  sub ProtoId_unpack {
\&    $rproto{$_[0]} || \*(Aqunknown protocol\*(Aq
\&  }
\&  
\&  sub ProtoId_pack {
\&    $proto{$_[0]} or die \*(Aqunknown protocol\*(Aq
\&  }
.Ve
.PP
You can now register these subroutines by attaching a \f(CW\*(C`Hooks\*(C'\fR tag
to \f(CW\*(C`ProtoId\*(C'\fR using the \f(CW\*(C`tag\*(C'\fR method:
.PP
.Vb 2
\&  $c\->tag(\*(AqProtoId\*(Aq, Hooks => { pack   => \e&ProtoId_pack,
\&                                unpack => \e&ProtoId_unpack });
.Ve
.PP
Doing exactly the same unpack on \f(CW\*(C`MsgHeader\*(C'\fR again would
now return:
.PP
.Vb 4
\&  $msg_header = {
\&    \*(Aqlen\*(Aq => 13,
\&    \*(Aqid\*(Aq => \*(AqDOGS\*(Aq
\&  };
.Ve
.PP
Actually, if you don't need the reverse operation, you don't even
have to register a \f(CW\*(C`pack\*(C'\fR hook. Or, even better, you can have a
more intelligent \f(CW\*(C`unpack\*(C'\fR hook that creates a dual-typed variable:
.PP
.Vb 1
\&  use Scalar::Util qw(dualvar);
\&  
\&  sub ProtoId_unpack2 {
\&    dualvar $_[0], $rproto{$_[0]} || \*(Aqunknown protocol\*(Aq
\&  }
\&  
\&  $c\->tag(\*(AqProtoId\*(Aq, Hooks => { unpack => \e&ProtoId_unpack2 });
\&  
\&  $msg_header = $c\->unpack(\*(AqMsgHeader\*(Aq, $data);
.Ve
.PP
Just as before, this would print
.PP
.Vb 4
\&  $msg_header = {
\&    \*(Aqlen\*(Aq => 13,
\&    \*(Aqid\*(Aq => \*(AqDOGS\*(Aq
\&  };
.Ve
.PP
but without requiring a \f(CW\*(C`pack\*(C'\fR hook for packing, at least as
long as you keep the variable dual-typed.
.PP
Hooks are usually called with exactly one argument, which is the
data that should be processed (see \*(L"Advanced Hooks\*(R" for details
on how to customize hook arguments). They are called in scalar
context and expected to return the processed data.
.PP
To get rid of registered hooks, you can either undefine only
certain hooks
.PP
.Vb 1
\&  $c\->tag(\*(AqProtoId\*(Aq, Hooks => { pack => undef });
.Ve
.PP
or all hooks:
.PP
.Vb 1
\&  $c\->tag(\*(AqProtoId\*(Aq, Hooks => undef);
.Ve
.PP
Of course, hooks are not restricted to handling integer values.
You could just as well attach hooks for the \f(CW\*(C`String\*(C'\fR struct from
the code above. A useful example would be to have these hooks:
.PP
.Vb 4
\&  sub string_unpack {
\&    my $s = shift;
\&    pack "c$s\->{len}", @{$s\->{buf}};
\&  }
\&  
\&  sub string_pack {
\&    my $s = shift;
\&    return {
\&      len => length $s,
\&      buf => [ unpack \*(Aqc*\*(Aq, $s ],
\&    }
\&  }
.Ve
.PP
(Don't be confused by the fact that the \f(CW\*(C`unpack\*(C'\fR hook
uses \f(CW\*(C`pack\*(C'\fR and the \f(CW\*(C`pack\*(C'\fR hook uses \f(CW\*(C`unpack\*(C'\fR.
And also see \*(L"Advanced Hooks\*(R" for a more clever approach.)
.PP
While you would normally get the following output when unpacking
a \f(CW\*(C`String\*(C'\fR
.PP
.Vb 10
\&  $string = {
\&    \*(Aqlen\*(Aq => 12,
\&    \*(Aqbuf\*(Aq => [
\&      72,
\&      101,
\&      108,
\&      108,
\&      111,
\&      32,
\&      87,
\&      111,
\&      114,
\&      108,
\&      100,
\&      33
\&    ]
\&  };
.Ve
.PP
you could just register the hooks using
.PP
.Vb 2
\&  $c\->tag(\*(AqString\*(Aq, Hooks => { pack   => \e&string_pack,
\&                               unpack => \e&string_unpack });
.Ve
.PP
and you would get a nice human-readable Perl string:
.PP
.Vb 1
\&  $string = \*(AqHello World!\*(Aq;
.Ve
.PP
Packing a string turns out to be just as easy:
.PP
.Vb 1
\&  use Data::Hexdumper;
\&  
\&  $data = $c\->pack(\*(AqString\*(Aq, \*(AqJust another Perl hacker,\*(Aq);
\&  
\&  print hexdump(data => $data);
.Ve
.PP
This would print:
.PP
.Vb 2
\&    0x0000 : 00 00 00 19 4A 75 73 74 20 61 6E 6F 74 68 65 72 : ....Just.another
\&    0x0010 : 20 50 65 72 6C 20 68 61 63 6B 65 72 2C          : .Perl.hacker,
.Ve
.PP
If you want to find out if or which hooks are registered for
a certain type, you can also use the \f(CW\*(C`tag\*(C'\fR method:
.PP
.Vb 1
\&  $hooks = $c\->tag(\*(AqString\*(Aq, \*(AqHooks\*(Aq);
.Ve
.PP
This would return:
.PP
.Vb 4
\&  $hooks = {
\&    \*(Aqunpack\*(Aq => \e&string_unpack,
\&    \*(Aqpack\*(Aq => \e&string_pack
\&  };
.Ve
.PP
\fIAdvanced Hooks\fR
.IX Subsection "Advanced Hooks"
.PP
It is also possible to combine hooks with using the \f(CW\*(C`Format\*(C'\fR tag.
This can be useful if you know better than Convert::Binary::C how
to interpret the binary data. In the previous section, we've handled
this type
.PP
.Vb 4
\&  struct String {
\&    u_32 len;
\&    char buf[];
\&  };
.Ve
.PP
with the following hooks:
.PP
.Vb 4
\&  sub string_unpack {
\&    my $s = shift;
\&    pack "c$s\->{len}", @{$s\->{buf}};
\&  }
\&  
\&  sub string_pack {
\&    my $s = shift;
\&    return {
\&      len => length $s,
\&      buf => [ unpack \*(Aqc*\*(Aq, $s ],
\&    }
\&  }
\&
\&  $c\->tag(\*(AqString\*(Aq, Hooks => { pack   => \e&string_pack,
\&                               unpack => \e&string_unpack });
.Ve
.PP
As you can see in the hook code, \f(CW\*(C`buf\*(C'\fR is expected to be an array
of characters. For the \f(CW\*(C`unpack\*(C'\fR case Convert::Binary::C
first turns the binary data into a Perl array, and then the hook packs
it back into a string. The intermediate array creation and destruction
is completely useless.
Same thing, of course, for the \f(CW\*(C`pack\*(C'\fR case.
.PP
Here's a clever way to handle this. Just tag \f(CW\*(C`buf\*(C'\fR as binary
.PP
.Vb 1
\&  $c\->tag(\*(AqString.buf\*(Aq, Format => \*(AqBinary\*(Aq);
.Ve
.PP
and use the following hooks instead:
.PP
.Vb 4
\&  sub string_unpack2 {
\&    my $s = shift;
\&    substr $s\->{buf}, 0, $s\->{len};
\&  }
\&  
\&  sub string_pack2 {
\&    my $s = shift;
\&    return {
\&      len => length $s,
\&      buf => $s,
\&    }
\&  }
\&  
\&  $c\->tag(\*(AqString\*(Aq, Hooks => { pack   => \e&string_pack2,
\&                               unpack => \e&string_unpack2 });
.Ve
.PP
This will be exactly equivalent to the old code, but faster and
probably even much easier to understand.
.PP
But hooks are even more powerful. You can customize the arguments
that are passed to your hooks and you can use \f(CW\*(C`arg\*(C'\fR to
pass certain special arguments, such as the name of the type that
is currently being processed by the hook.
.PP
The following example shows how it is easily possible to peek into
the perl internals using hooks.
.PP
.Vb 1
\&  use Config;
\&  
\&  $c = new Convert::Binary::C %CC, OrderMembers => 1;
\&  $c\->Include(["$Config{archlib}/CORE", @{$c\->Include}]);
\&  $c\->parse(<<ENDC);
\&  #include "EXTERN.h"
\&  #include "perl.h"
\&  ENDC
\&  
\&  $c\->tag($_, Hooks => { unpack_ptr => [\e&unpack_ptr,
\&                                        $c\->arg(qw(SELF TYPE DATA))] })
\&      for qw( XPVAV XPVHV );
.Ve
.PP
First, we add the perl core include path and parse \fIperl.h\fR. Then,
we add an \f(CW\*(C`unpack_ptr\*(C'\fR hook for a couple of the internal data types.
.PP
The \f(CW\*(C`unpack_ptr\*(C'\fR and \f(CW\*(C`pack_ptr\*(C'\fR hooks are called whenever a pointer
to a certain data structure is processed. This is by far the most
experimental part of the hooks feature, as this includes \fBany\fR kind
of pointer. There's no way for the hook to know the difference between
a plain pointer, or a pointer to a pointer, or a pointer to an array
(this is because the difference doesn't matter anywhere else in
Convert::Binary::C).
.PP
But the hook above makes use of another very interesting feature: It
uses \f(CW\*(C`arg\*(C'\fR to pass special arguments to the hook subroutine.
Usually, the hook subroutine is simply passed a single data argument.
But using the above definition, it'll get a reference to the calling
object (\f(CW\*(C`SELF\*(C'\fR), the name of the type being processed (\f(CW\*(C`TYPE\*(C'\fR) and
the data (\f(CW\*(C`DATA\*(C'\fR).
.PP
But how does our hook look like?
.PP
.Vb 6
\&  sub unpack_ptr {
\&    my($self, $type, $ptr) = @_;
\&    $ptr or return \*(Aq<NULL>\*(Aq;
\&    my $size = $self\->sizeof($type);
\&    $self\->unpack($type, unpack("P$size", pack(\*(AqI\*(Aq, $ptr)));
\&  }
.Ve
.PP
As you can see, the hook is rather simple. First, it receives the
arguments mentioned above. It performs a quick check if the pointer
is \f(CW\*(C`NULL\*(C'\fR and shouldn't be processed any further. Next, it determines
the size of the type being processed. And finally, it'll just use
the \f(CW\*(C`P\*(C'\fR\fIn\fR unpack template to read from that memory location and
recursively call \f(CW\*(C`unpack\*(C'\fR to unpack the type. (And yes,
this may of course again call other hooks.)
.PP
Now, let's test that:
.PP
.Vb 2
\&  my $ref = { foo => 42, bar => 4711 };
\&  my $ptr = hex(("$ref" =~ /\e(0x([[:xdigit:]]+)\e)$/)[0]);
\&  
\&  print Dumper(unpack_ptr($c, \*(AqAV\*(Aq, $ptr));
.Ve
.PP
Just for the fun of it, we create a blessed array reference. But how
do we get a pointer to the corresponding \f(CW\*(C`AV\*(C'\fR? This is rather easy,
as the address of the \f(CW\*(C`AV\*(C'\fR is just the hex value that appears when
using the array reference in string context. So we just grab that and
turn it into decimal. All that's left to do is just call our hook,
as it can already handle \f(CW\*(C`AV\*(C'\fR pointers. And this is what we get:
.PP
.Vb 10
\&  $VAR1 = {
\&    \*(Aqsv_any\*(Aq => {
\&      \*(Aqxnv_u\*(Aq => {
\&        \*(Aqxnv_nv\*(Aq => \*(Aq0\*(Aq,
\&        \*(Aqxgv_stash\*(Aq => 0,
\&        \*(Aqxpad_cop_seq\*(Aq => {
\&          \*(Aqxlow\*(Aq => 0,
\&          \*(Aqxhigh\*(Aq => 0
\&        },
\&        \*(Aqxbm_s\*(Aq => {
\&          \*(Aqxbm_previous\*(Aq => 0,
\&          \*(Aqxbm_flags\*(Aq => 0,
\&          \*(Aqxbm_rare\*(Aq => 0
\&        }
\&      },
\&      \*(Aqxav_fill\*(Aq => 2,
\&      \*(Aqxav_max\*(Aq => 7,
\&      \*(Aqxiv_u\*(Aq => {
\&        \*(Aqxivu_iv\*(Aq => 2,
\&        \*(Aqxivu_uv\*(Aq => 2,
\&        \*(Aqxivu_p1\*(Aq => 2,
\&        \*(Aqxivu_i32\*(Aq => 2,
\&        \*(Aqxivu_namehek\*(Aq => 2,
\&        \*(Aqxivu_hv\*(Aq => 2
\&      },
\&      \*(Aqxmg_u\*(Aq => {
\&        \*(Aqxmg_magic\*(Aq => 0,
\&        \*(Aqxmg_ourstash\*(Aq => 0
\&      },
\&      \*(Aqxmg_stash\*(Aq => 0
\&    },
\&    \*(Aqsv_refcnt\*(Aq => 1,
\&    \*(Aqsv_flags\*(Aq => 536870924,
\&    \*(Aqsv_u\*(Aq => {
\&      \*(Aqsvu_pv\*(Aq => 142054140,
\&      \*(Aqsvu_iv\*(Aq => 142054140,
\&      \*(Aqsvu_uv\*(Aq => 142054140,
\&      \*(Aqsvu_rv\*(Aq => 142054140,
\&      \*(Aqsvu_array\*(Aq => 142054140,
\&      \*(Aqsvu_hash\*(Aq => 142054140,
\&      \*(Aqsvu_gp\*(Aq => 142054140
\&    }
\&  };
.Ve
.PP
Even though it is rather easy to do such stuff using \f(CW\*(C`unpack_ptr\*(C'\fR hooks,
you should really know what you're doing and do it with extreme care
because of the limitations mentioned above. It's really easy to run into
segmentation faults when you're dereferencing pointers that point to
memory which you don't own.
.PP
\fIPerformance\fR
.IX Subsection "Performance"
.PP
Using hooks isn't for free. In performance-critical applications
you have to keep in mind that hooks are actually perl subroutines
and that they are called once for every value of a registered
type that is being packed or unpacked. If only about 10% of the
values require hooks to be called, you'll hardly notice the
difference (if your hooks are implemented efficiently, that is).
But if all values would require hooks to be called, that alone
could easily make packing and unpacking very slow.
.SS "Tag Order"
.IX Subsection "Tag Order"
Since it is possible to attach multiple tags to a single type,
the order in which the tags are processed is important. Here's
a small table that shows the processing order.
.PP
.Vb 5
\&  pack        unpack
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Hooks       Format
\&  Format      ByteOrder
\&  ByteOrder   Hooks
.Ve
.PP
As a general rule, the \f(CW\*(C`Hooks\*(C'\fR tag is always
the first thing processed when packing data, and the last thing
processed when unpacking data.
.PP
The \f(CW\*(C`Format\*(C'\fR and \f(CW\*(C`ByteOrder\*(C'\fR tags
are exclusive, but when both are given the \f(CW\*(C`Format\*(C'\fR tag
wins.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.ie n .IP """new""" 8
.el .IP "\f(CWnew\fR" 8
.IX Item "new"
.PD 0
.ie n .IP """new"" \s-1OPTION1\s0 => \s-1VALUE1, OPTION2\s0 => \s-1VALUE2, ...\s0" 8
.el .IP "\f(CWnew\fR \s-1OPTION1\s0 => \s-1VALUE1, OPTION2\s0 => \s-1VALUE2, ...\s0" 8
.IX Item "new OPTION1 => VALUE1, OPTION2 => VALUE2, ..."
.PD
The constructor is used to create a new Convert::Binary::C object.
You can simply use
.Sp
.Vb 1
\&  $c = new Convert::Binary::C;
.Ve
.Sp
without additional arguments to create an object, or you can
optionally pass any arguments to the constructor that are
described for the \f(CW\*(C`configure\*(C'\fR method.
.SS "configure"
.IX Subsection "configure"
.ie n .IP """configure""" 8
.el .IP "\f(CWconfigure\fR" 8
.IX Item "configure"
.PD 0
.ie n .IP """configure"" \s-1OPTION\s0" 8
.el .IP "\f(CWconfigure\fR \s-1OPTION\s0" 8
.IX Item "configure OPTION"
.ie n .IP """configure"" \s-1OPTION1\s0 => \s-1VALUE1, OPTION2\s0 => \s-1VALUE2, ...\s0" 8
.el .IP "\f(CWconfigure\fR \s-1OPTION1\s0 => \s-1VALUE1, OPTION2\s0 => \s-1VALUE2, ...\s0" 8
.IX Item "configure OPTION1 => VALUE1, OPTION2 => VALUE2, ..."
.PD
This method can be used to configure an existing Convert::Binary::C
object or to retrieve its current configuration.
.Sp
To configure the object, the list of options consists of key
and value pairs and must therefore contain an even number of
elements. \f(CW\*(C`configure\*(C'\fR (and also \f(CW\*(C`new\*(C'\fR if
used with configuration options) will throw an exception if you
pass an odd number of elements. Configuration will normally look
like this:
.Sp
.Vb 1
\&  $c\->configure(ByteOrder => \*(AqBigEndian\*(Aq, IntSize => 2);
.Ve
.Sp
To retrieve the current value of a configuration option, you
must pass a single argument to \f(CW\*(C`configure\*(C'\fR that
holds the name of the option, just like
.Sp
.Vb 1
\&  $order = $c\->configure(\*(AqByteOrder\*(Aq);
.Ve
.Sp
If you want to get the values of all configuration options at
once, you can call \f(CW\*(C`configure\*(C'\fR without any
arguments and it will return a reference to a hash table that
holds the whole object configuration. This can be conveniently
used with the Data::Dumper module, for example:
.Sp
.Vb 2
\&  use Convert::Binary::C;
\&  use Data::Dumper;
\&  
\&  $c = new Convert::Binary::C Define  => [\*(AqDEBUGGING\*(Aq, \*(AqFOO=123\*(Aq],
\&                              Include => [\*(Aq/usr/include\*(Aq];
\&  
\&  print Dumper($c\->configure);
.Ve
.Sp
Which will print something like this:
.Sp
.Vb 10
\&  $VAR1 = {
\&    \*(AqDefine\*(Aq => [
\&      \*(AqDEBUGGING\*(Aq,
\&      \*(AqFOO=123\*(Aq
\&    ],
\&    \*(AqStdCVersion\*(Aq => 199901,
\&    \*(AqByteOrder\*(Aq => \*(AqLittleEndian\*(Aq,
\&    \*(AqLongSize\*(Aq => 4,
\&    \*(AqIntSize\*(Aq => 4,
\&    \*(AqHostedC\*(Aq => 1,
\&    \*(AqShortSize\*(Aq => 2,
\&    \*(AqHasMacroVAARGS\*(Aq => 1,
\&    \*(AqAssert\*(Aq => [],
\&    \*(AqUnsignedChars\*(Aq => 0,
\&    \*(AqDoubleSize\*(Aq => 8,
\&    \*(AqCharSize\*(Aq => 1,
\&    \*(AqEnumType\*(Aq => \*(AqInteger\*(Aq,
\&    \*(AqPointerSize\*(Aq => 4,
\&    \*(AqEnumSize\*(Aq => 4,
\&    \*(AqDisabledKeywords\*(Aq => [],
\&    \*(AqFloatSize\*(Aq => 4,
\&    \*(AqAlignment\*(Aq => 1,
\&    \*(AqLongLongSize\*(Aq => 8,
\&    \*(AqLongDoubleSize\*(Aq => 12,
\&    \*(AqKeywordMap\*(Aq => {},
\&    \*(AqInclude\*(Aq => [
\&      \*(Aq/usr/include\*(Aq
\&    ],
\&    \*(AqHasCPPComments\*(Aq => 1,
\&    \*(AqBitfields\*(Aq => {
\&      \*(AqEngine\*(Aq => \*(AqGeneric\*(Aq
\&    },
\&    \*(AqUnsignedBitfields\*(Aq => 0,
\&    \*(AqWarnings\*(Aq => 0,
\&    \*(AqCompoundAlignment\*(Aq => 1,
\&    \*(AqOrderMembers\*(Aq => 0
\&  };
.Ve
.Sp
Since you may not always want to write a \f(CW\*(C`configure\*(C'\fR call
when you only want to change a single configuration item, you can
use any configuration option name as a method name, like:
.Sp
.Vb 1
\&  $c\->ByteOrder(\*(AqLittleEndian\*(Aq) if $c\->IntSize < 4;
.Ve
.Sp
(Yes, the example doesn't make very much sense... ;\-)
.Sp
However, you should keep in mind that configuration methods
that can take lists (namely \f(CW\*(C`Include\*(C'\fR, \f(CW\*(C`Define\*(C'\fR and \f(CW\*(C`Assert\*(C'\fR,
but not \f(CW\*(C`DisabledKeywords\*(C'\fR) may behave slightly different than
their \f(CW\*(C`configure\*(C'\fR equivalent.
If you pass these methods a single argument that is an array
reference, the current list will be \fBreplaced\fR by the new one,
which is just the behaviour of the
corresponding \f(CW\*(C`configure\*(C'\fR call.
So the following are equivalent:
.Sp
.Vb 2
\&  $c\->configure(Define => [\*(Aqfoo\*(Aq, \*(Aqbar=123\*(Aq]);
\&  $c\->Define([\*(Aqfoo\*(Aq, \*(Aqbar=123\*(Aq]);
.Ve
.Sp
But if you pass a list of strings instead of an array reference
(which cannot be done when using \f(CW\*(C`configure\*(C'\fR),
the new list items are \fBappended\fR to the current list, so
.Sp
.Vb 3
\&  $c = new Convert::Binary::C Include => [\*(Aq/include\*(Aq];
\&  $c\->Include(\*(Aq/usr/include\*(Aq, \*(Aq/usr/local/include\*(Aq);
\&  print Dumper($c\->Include);
\&  
\&  $c\->Include([\*(Aq/usr/local/include\*(Aq]);
\&  print Dumper($c\->Include);
.Ve
.Sp
will first print all three include paths, but finally
only \f(CW\*(C`/usr/local/include\*(C'\fR will be configured:
.Sp
.Vb 8
\&  $VAR1 = [
\&    \*(Aq/include\*(Aq,
\&    \*(Aq/usr/include\*(Aq,
\&    \*(Aq/usr/local/include\*(Aq
\&  ];
\&  $VAR1 = [
\&    \*(Aq/usr/local/include\*(Aq
\&  ];
.Ve
.Sp
Furthermore, configuration methods can be chained together,
as they return a reference to their object if called as a
set method. So, if you like, you can configure your object
like this:
.Sp
.Vb 3
\&  $c = Convert::Binary::C\->new(IntSize => 4)
\&         \->Define(qw( _\|_DEBUG_\|_ DB_LEVEL=3 ))
\&         \->ByteOrder(\*(AqBigEndian\*(Aq);
\&  
\&  $c\->configure(EnumType => \*(AqBoth\*(Aq, Alignment => 4)
\&    \->Include(\*(Aq/usr/include\*(Aq, \*(Aq/usr/local/include\*(Aq);
.Ve
.Sp
In the example above, \f(CW\*(C`qw( ... )\*(C'\fR is the word list quoting
operator. It returns a list of all non-whitespace sequences,
and is especially useful for configuring preprocessor defines
or assertions. The following assignments are equivalent:
.Sp
.Vb 2
\&  @array = (\*(Aqone\*(Aq, \*(Aqtwo\*(Aq, \*(Aqthree\*(Aq);
\&  @array = qw(one two three);
.Ve
.Sp
You can configure the following options. Unknown options, as well
as invalid values for an option, will cause the object to throw
exceptions.
.RS 8
.ie n .IP """IntSize"" => 0 | 1 | 2 | 4 | 8" 4
.el .IP "\f(CWIntSize\fR => 0 | 1 | 2 | 4 | 8" 4
.IX Item "IntSize => 0 | 1 | 2 | 4 | 8"
Set the number of bytes that are occupied by an integer. This is
in most cases 2 or 4. If you set it to zero, the size of an
integer on the host system will be used. This is also the
default unless overridden by \f(CW\*(C`CBC_DEFAULT_INT_SIZE\*(C'\fR at compile time.
.ie n .IP """CharSize"" => 0 | 1 | 2 | 4 | 8" 4
.el .IP "\f(CWCharSize\fR => 0 | 1 | 2 | 4 | 8" 4
.IX Item "CharSize => 0 | 1 | 2 | 4 | 8"
Set the number of bytes that are occupied by a \f(CW\*(C`char\*(C'\fR.
This rarely needs to be changed, except for some platforms
that don't care about bytes, for example DSPs.
If you set this to zero, the size of a \f(CW\*(C`char\*(C'\fR on the host
system will be used. This is also the default unless
overridden by \f(CW\*(C`CBC_DEFAULT_CHAR_SIZE\*(C'\fR at compile time.
.ie n .IP """ShortSize"" => 0 | 1 | 2 | 4 | 8" 4
.el .IP "\f(CWShortSize\fR => 0 | 1 | 2 | 4 | 8" 4
.IX Item "ShortSize => 0 | 1 | 2 | 4 | 8"
Set the number of bytes that are occupied by a short integer.
Although integers explicitly declared as \f(CW\*(C`short\*(C'\fR should be
always 16 bit, there are compilers that make a short
8 bit wide. If you set it to zero, the size of a short
integer on the host system will be used. This is also the
default unless overridden by \f(CW\*(C`CBC_DEFAULT_SHORT_SIZE\*(C'\fR at compile
time.
.ie n .IP """LongSize"" => 0 | 1 | 2 | 4 | 8" 4
.el .IP "\f(CWLongSize\fR => 0 | 1 | 2 | 4 | 8" 4
.IX Item "LongSize => 0 | 1 | 2 | 4 | 8"
Set the number of bytes that are occupied by a long integer.
If set to zero, the size of a long integer on the host system
will be used. This is also the default unless overridden
by \f(CW\*(C`CBC_DEFAULT_LONG_SIZE\*(C'\fR at compile time.
.ie n .IP """LongLongSize"" => 0 | 1 | 2 | 4 | 8" 4
.el .IP "\f(CWLongLongSize\fR => 0 | 1 | 2 | 4 | 8" 4
.IX Item "LongLongSize => 0 | 1 | 2 | 4 | 8"
Set the number of bytes that are occupied by a long long
integer. If set to zero, the size of a long long integer
on the host system, or 8, will be used. This is also the
default unless overridden by \f(CW\*(C`CBC_DEFAULT_LONG_LONG_SIZE\*(C'\fR at
compile time.
.ie n .IP """FloatSize"" => 0 | 1 | 2 | 4 | 8 | 12 | 16" 4
.el .IP "\f(CWFloatSize\fR => 0 | 1 | 2 | 4 | 8 | 12 | 16" 4
.IX Item "FloatSize => 0 | 1 | 2 | 4 | 8 | 12 | 16"
Set the number of bytes that are occupied by a single
precision floating point value.
If you set it to zero, the size of a \f(CW\*(C`float\*(C'\fR on the
host system will be used. This is also the default unless
overridden by \f(CW\*(C`CBC_DEFAULT_FLOAT_SIZE\*(C'\fR at compile time.
For details on floating point support,
see \*(L"\s-1FLOATING POINT VALUES\*(R"\s0.
.ie n .IP """DoubleSize"" => 0 | 1 | 2 | 4 | 8 | 12 | 16" 4
.el .IP "\f(CWDoubleSize\fR => 0 | 1 | 2 | 4 | 8 | 12 | 16" 4
.IX Item "DoubleSize => 0 | 1 | 2 | 4 | 8 | 12 | 16"
Set the number of bytes that are occupied by a double
precision floating point value.
If you set it to zero, the size of a \f(CW\*(C`double\*(C'\fR on the
host system will be used. This is also the default unless
overridden by \f(CW\*(C`CBC_DEFAULT_DOUBLE_SIZE\*(C'\fR at compile time.
For details on floating point support,
see \*(L"\s-1FLOATING POINT VALUES\*(R"\s0.
.ie n .IP """LongDoubleSize"" => 0 | 1 | 2 | 4 | 8 | 12 | 16" 4
.el .IP "\f(CWLongDoubleSize\fR => 0 | 1 | 2 | 4 | 8 | 12 | 16" 4
.IX Item "LongDoubleSize => 0 | 1 | 2 | 4 | 8 | 12 | 16"
Set the number of bytes that are occupied by a double
precision floating point value.
If you set it to zero, the size of a \f(CW\*(C`long double\*(C'\fR on
the host system, or 12 will be used. This is also the
default unless overridden by \f(CW\*(C`CBC_DEFAULT_LONG_DOUBLE_SIZE\*(C'\fR at compile
time. For details on floating point support,
see \*(L"\s-1FLOATING POINT VALUES\*(R"\s0.
.ie n .IP """PointerSize"" => 0 | 1 | 2 | 4 | 8" 4
.el .IP "\f(CWPointerSize\fR => 0 | 1 | 2 | 4 | 8" 4
.IX Item "PointerSize => 0 | 1 | 2 | 4 | 8"
Set the number of bytes that are occupied by a pointer. This is
in most cases 2 or 4. If you set it to zero, the size of a
pointer on the host system will be used. This is also the
default unless overridden by \f(CW\*(C`CBC_DEFAULT_PTR_SIZE\*(C'\fR at compile time.
.ie n .IP """EnumSize"" => \-1 | 0 | 1 | 2 | 4 | 8" 4
.el .IP "\f(CWEnumSize\fR => \-1 | 0 | 1 | 2 | 4 | 8" 4
.IX Item "EnumSize => -1 | 0 | 1 | 2 | 4 | 8"
Set the number of bytes that are occupied by an enumeration type.
On most systems, this is equal to the size of an integer,
which is also the default. However, for some compilers, the
size of an enumeration type depends on the size occupied by the
largest enumerator. So the size may vary between 1 and 8. If you
have
.Sp
.Vb 3
\&  enum foo {
\&    ONE = 100, TWO = 200
\&  };
.Ve
.Sp
this will occupy one byte because the enum can be represented
as an unsigned one-byte value. However,
.Sp
.Vb 3
\&  enum foo {
\&    ONE = \-100, TWO = 200
\&  };
.Ve
.Sp
will occupy two bytes, because the \-100 forces the type to
be signed, and 200 doesn't fit into a signed one-byte value.
Therefore, the type used is a signed two-byte value.
If this is the behaviour you need, set the EnumSize to \f(CW0\fR.
.Sp
Some compilers try to follow this strategy, but don't care
whether the enumeration has signed values or not. They always
declare an enum as signed. On such a compiler, given
.Sp
.Vb 2
\&  enum one { ONE = \-100, TWO = 100 };
\&  enum two { ONE =  100, TWO = 200 };
.Ve
.Sp
enum \f(CW\*(C`one\*(C'\fR will occupy only one byte, while enum \f(CW\*(C`two\*(C'\fR
will occupy two bytes, even though it could be represented
by a unsigned one-byte value. If this is the behaviour of
your compiler, set EnumSize to \f(CW\*(C`\-1\*(C'\fR.
.ie n .IP """Alignment"" => 0 | 1 | 2 | 4 | 8 | 16" 4
.el .IP "\f(CWAlignment\fR => 0 | 1 | 2 | 4 | 8 | 16" 4
.IX Item "Alignment => 0 | 1 | 2 | 4 | 8 | 16"
Set the struct member alignment. This option controls where
padding bytes are inserted between struct members. It globally
sets the alignment for all structs/unions. However, this can
be overridden from within the source code with the
common \f(CW\*(C`pack\*(C'\fR pragma as explained in \*(L"Supported pragma directives\*(R".
The default alignment is 1, which means no padding bytes are
inserted. A setting of \f(CW0\fR means \fInative\fR alignment, i.e.
the alignment of the system that Convert::Binary::C has been
compiled on. You can determine the native properties using
the \f(CW\*(C`native\*(C'\fR function.
.Sp
The \f(CW\*(C`Alignment\*(C'\fR option is similar to the \f(CW\*(C`\-Zp[n]\*(C'\fR option
of the Intel compiler. It globally specifies the maximum
boundary to which struct members are aligned. Consider the
following structure and the sizes
of \f(CW\*(C`char\*(C'\fR, \f(CW\*(C`short\*(C'\fR, \f(CW\*(C`long\*(C'\fR and \f(CW\*(C`double\*(C'\fR being 1, 2, 4
and 8, respectively.
.Sp
.Vb 6
\&  struct align {
\&    char   a;
\&    short  b, c;
\&    long   d;
\&    double e;
\&  };
.Ve
.Sp
With an alignment of 1 (the default), the struct members would
be packed tightly:
.Sp
.Vb 4
\&  0   1   2   3   4   5   6   7   8   9  10  11  12
\&  +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  | a |   b   |   c   |       d       |             ...
\&  +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  
\&     12  13  14  15  16  17
\&      +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  ...     e               |
\&      +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
.Ve
.Sp
With an alignment of 2, the struct members larger than one byte
would be aligned to 2\-byte boundaries, which results in a single
padding byte between \f(CW\*(C`a\*(C'\fR and \f(CW\*(C`b\*(C'\fR.
.Sp
.Vb 4
\&  0   1   2   3   4   5   6   7   8   9  10  11  12
\&  +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  | a | * |   b   |   c   |       d       |         ...
\&  +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  
\&     12  13  14  15  16  17  18
\&      +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  ...         e               |
\&      +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
.Ve
.Sp
With an alignment of 4, the struct members of size 2 would be
aligned to 2\-byte boundaries and larger struct members would
be aligned to 4\-byte boundaries:
.Sp
.Vb 4
\&  0   1   2   3   4   5   6   7   8   9  10  11  12
\&  +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  | a | * |   b   |   c   | * | * |       d       | ...
\&  +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  
\&     12  13  14  15  16  17  18  19  20
\&      +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  ... |               e               |
\&      +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
.Ve
.Sp
This layout of the struct members allows the compiler to generate
optimized code because aligned members can be accessed more easily
by the underlying architecture.
.Sp
Finally, setting the alignment to 8 will align \f(CW\*(C`double\*(C'\fRs to
8\-byte boundaries:
.Sp
.Vb 4
\&  0   1   2   3   4   5   6   7   8   9  10  11  12
\&  +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  | a | * |   b   |   c   | * | * |       d       | ...
\&  +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  
\&     12  13  14  15  16  17  18  19  20  21  22  23  24
\&      +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  ... | * | * | * | * |               e               |
\&      +\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+\-\-\-+
.Ve
.Sp
Further increasing the alignment does not alter the layout of
our structure, as only members larger that 8 bytes would be
affected.
.Sp
The alignment of a structure depends on its largest member and
on the setting of the \f(CW\*(C`Alignment\*(C'\fR option. With \f(CW\*(C`Alignment\*(C'\fR set
to 2, a structure holding a \f(CW\*(C`long\*(C'\fR would be aligned to a 2\-byte
boundary, while a structure containing only \f(CW\*(C`char\*(C'\fRs would have
no alignment restrictions. (Unfortunately, that's not the whole
story. See the \f(CW\*(C`CompoundAlignment\*(C'\fR option for details.)
.Sp
Here's another example. Assuming 8\-byte alignment, the following
two structs will both have a size of 16 bytes:
.Sp
.Vb 4
\&  struct one {
\&    char   c;
\&    double d;
\&  };
\&  
\&  struct two {
\&    double d;
\&    char   c;
\&  };
.Ve
.Sp
This is clear for \f(CW\*(C`struct one\*(C'\fR, because the member \f(CW\*(C`d\*(C'\fR has to
be aligned to an 8\-byte boundary, and thus 7 padding bytes are
inserted after \f(CW\*(C`c\*(C'\fR. But for \f(CW\*(C`struct two\*(C'\fR, the padding bytes
are inserted \fBat the end\fR of the structure, which doesn't make
much sense immediately. However, it makes perfect sense if you
think about an array of \f(CW\*(C`struct two\*(C'\fR. Each \f(CW\*(C`double\*(C'\fR has to be
aligned to an 8\-byte boundary, an thus each array element would
have to occupy 16 bytes. With that in mind, it would be strange
if a \f(CW\*(C`struct two\*(C'\fR variable would have a different size. And it
would make the widely used construct
.Sp
.Vb 2
\&  struct two array[] = { {1.0, 0}, {2.0, 1} };
\&  int elements = sizeof(array) / sizeof(struct two);
.Ve
.Sp
impossible.
.Sp
The alignment behaviour described here seems to be common for all
compilers. However, not all compilers have an option to configure
their default alignment.
.ie n .IP """CompoundAlignment"" => 0 | 1 | 2 | 4 | 8 | 16" 4
.el .IP "\f(CWCompoundAlignment\fR => 0 | 1 | 2 | 4 | 8 | 16" 4
.IX Item "CompoundAlignment => 0 | 1 | 2 | 4 | 8 | 16"
Usually, the alignment of a compound (i.e. a \f(CW\*(C`struct\*(C'\fR or
a \f(CW\*(C`union\*(C'\fR) depends only on its largest member and on the setting
of the \f(CW\*(C`Alignment\*(C'\fR option. There are, however, architectures and
compilers where compounds can have different alignment constraints.
.Sp
For most platforms and compilers, the alignment constraint for
compounds is 1 byte. That is, on most platforms
.Sp
.Vb 3
\&  struct onebyte {
\&    char byte;
\&  };
.Ve
.Sp
will have an alignment of 1 and also a size of 1. But if you take
an \s-1ARM\s0 architecture, the above \f(CW\*(C`struct onebyte\*(C'\fR will have an
alignment of 4, and thus also a size of 4.
.Sp
You can configure this by setting \f(CW\*(C`CompoundAlignment\*(C'\fR to 4. This
will ensure that the alignment of compounds is always 4.
.Sp
Setting \f(CW\*(C`CompoundAlignment\*(C'\fR to \f(CW0\fR means \fInative\fR compound
alignment, i.e. the compound alignment of the system that
Convert::Binary::C has been compiled on. You can determine the
native properties using the \f(CW\*(C`native\*(C'\fR function.
.Sp
There are also compilers for certain platforms that allow you to
adjust the compound alignment. If you're not aware of the fact
that your compiler/architecture has a compound alignment other
than 1, strange things can happen. If, for example, the compound
alignment is 2 and you have something like
.Sp
.Vb 1
\&  typedef unsigned char U8;
\&  
\&  struct msg_head {
\&    U8 cmd;
\&    struct {
\&      U8 hi;
\&      U8 low;
\&    } crc16;
\&    U8 len;
\&  };
.Ve
.Sp
there will be one padding byte inserted before the
embedded \f(CW\*(C`crc16\*(C'\fR struct and after the \f(CW\*(C`len\*(C'\fR member, which
is most probably not what was intended:
.Sp
.Vb 4
\&  0     1     2     3     4     5     6
\&  +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+
\&  | cmd |  *  | hi  | low | len |  *  |
\&  +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+
.Ve
.Sp
Note that both \f(CW\*(C`#pragma pack\*(C'\fR and the \f(CW\*(C`Alignment\*(C'\fR option can
override \f(CW\*(C`CompoundAlignment\*(C'\fR. If you set \f(CW\*(C`CompoundAlignment\*(C'\fR to
4, but \f(CW\*(C`Alignment\*(C'\fR to 2, compounds will actually be aligned on
2\-byte boundaries.
.ie n .IP """ByteOrder"" => 'BigEndian' | 'LittleEndian'" 4
.el .IP "\f(CWByteOrder\fR => 'BigEndian' | 'LittleEndian'" 4
.IX Item "ByteOrder => 'BigEndian' | 'LittleEndian'"
Set the byte order for integers larger than a single byte.
Little endian (Intel, least significant byte first) and
big endian (Motorola, most significant byte first) byte
order are supported. The default byte order is the same as
the byte order of the host system unless overridden
by \f(CW\*(C`CBC_DEFAULT_BYTEORDER\*(C'\fR at compile time.
.ie n .IP """EnumType"" => 'Integer' | 'String' | 'Both'" 4
.el .IP "\f(CWEnumType\fR => 'Integer' | 'String' | 'Both'" 4
.IX Item "EnumType => 'Integer' | 'String' | 'Both'"
This option controls the type that enumeration constants
will have in data structures returned by the \f(CW\*(C`unpack\*(C'\fR method.
If you have the following definitions:
.Sp
.Vb 4
\&  typedef enum {
\&    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
\&    THURSDAY, FRIDAY, SATURDAY
\&  } Weekday;
\&  
\&  typedef enum {
\&    JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY,
\&    AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER
\&  } Month;
\&  
\&  typedef struct {
\&    int     year;
\&    Month   month;
\&    int     day;
\&    Weekday weekday;
\&  } Date;
.Ve
.Sp
and a byte string that holds a packed Date struct,
then you'll get the following results from a call
to the \f(CW\*(C`unpack\*(C'\fR method.
.RS 4
.ie n .IP """Integer""" 4
.el .IP "\f(CWInteger\fR" 4
.IX Item "Integer"
Enumeration constants are returned as plain integers. This
is fast, but may be not very useful. It is also the default.
.Sp
.Vb 6
\&  $date = {
\&    \*(Aqweekday\*(Aq => 1,
\&    \*(Aqmonth\*(Aq => 0,
\&    \*(Aqday\*(Aq => 7,
\&    \*(Aqyear\*(Aq => 2002
\&  };
.Ve
.ie n .IP """String""" 4
.el .IP "\f(CWString\fR" 4
.IX Item "String"
Enumeration constants are returned as strings. This will
create a string constant for every unpacked enumeration
constant and thus consumes more time and memory. However,
the result may be more useful.
.Sp
.Vb 6
\&  $date = {
\&    \*(Aqweekday\*(Aq => \*(AqMONDAY\*(Aq,
\&    \*(Aqmonth\*(Aq => \*(AqJANUARY\*(Aq,
\&    \*(Aqday\*(Aq => 7,
\&    \*(Aqyear\*(Aq => 2002
\&  };
.Ve
.ie n .IP """Both""" 4
.el .IP "\f(CWBoth\fR" 4
.IX Item "Both"
Enumeration constants are returned as double typed scalars.
If evaluated in string context, the enumeration constant
will be a string, if evaluated in numeric context, the
enumeration constant will be an integer.
.Sp
.Vb 1
\&  $date = $c\->EnumType(\*(AqBoth\*(Aq)\->unpack(\*(AqDate\*(Aq, $binary);
\&  
\&  printf "Weekday = %s (%d)\en\en", $date\->{weekday},
\&                                  $date\->{weekday};
\&  
\&  if ($date\->{month} == 0) {
\&    print "It\*(Aqs $date\->{month}, happy new year!\en\en";
\&  }
\&  
\&  print Dumper($date);
.Ve
.Sp
This will print:
.Sp
.Vb 1
\&  Weekday = MONDAY (1)
\&  
\&  It\*(Aqs JANUARY, happy new year!
\&  
\&  $VAR1 = {
\&    \*(Aqweekday\*(Aq => \*(AqMONDAY\*(Aq,
\&    \*(Aqmonth\*(Aq => \*(AqJANUARY\*(Aq,
\&    \*(Aqday\*(Aq => 7,
\&    \*(Aqyear\*(Aq => 2002
\&  };
.Ve
.RE
.RS 4
.RE
.ie n .IP """DisabledKeywords"" => [ \s-1KEYWORDS \s0]" 4
.el .IP "\f(CWDisabledKeywords\fR => [ \s-1KEYWORDS \s0]" 4
.IX Item "DisabledKeywords => [ KEYWORDS ]"
This option allows you to selectively deactivate certain
keywords in the C parser. Some C compilers don't have
the complete \s-1ANSI\s0 keyword set, i.e. they don't recognize
the keywords \f(CW\*(C`const\*(C'\fR or \f(CW\*(C`void\*(C'\fR, for example. If you do
.Sp
.Vb 1
\&  typedef int void;
.Ve
.Sp
on such a compiler, this will usually be ok. But if you
parse this with an \s-1ANSI\s0 compiler, it will be a syntax
error. To parse the above code correctly, you have to
disable the \f(CW\*(C`void\*(C'\fR keyword in the Convert::Binary::C
parser:
.Sp
.Vb 1
\&  $c\->DisabledKeywords([qw( void )]);
.Ve
.Sp
By default, the Convert::Binary::C parser will recognize
the keywords \f(CW\*(C`inline\*(C'\fR and \f(CW\*(C`restrict\*(C'\fR. If your compiler
doesn't have these new keywords, it usually doesn't matter.
Only if you're using the keywords as identifiers, like in
.Sp
.Vb 3
\&  typedef struct inline {
\&    int a, b;
\&  } restrict;
.Ve
.Sp
you'll have to disable these \s-1ISO\-C99\s0 keywords:
.Sp
.Vb 1
\&  $c\->DisabledKeywords([qw( inline restrict )]);
.Ve
.Sp
The parser allows you to disable the following keywords:
.Sp
.Vb 10
\&  asm
\&  auto
\&  const
\&  double
\&  enum
\&  extern
\&  float
\&  inline
\&  long
\&  register
\&  restrict
\&  short
\&  signed
\&  static
\&  unsigned
\&  void
\&  volatile
.Ve
.ie n .IP """KeywordMap"" => { \s-1KEYWORD\s0 => \s-1TOKEN, ... \s0}" 4
.el .IP "\f(CWKeywordMap\fR => { \s-1KEYWORD\s0 => \s-1TOKEN, ... \s0}" 4
.IX Item "KeywordMap => { KEYWORD => TOKEN, ... }"
This option allows you to add new keywords to the parser.
These new keywords can either be mapped to existing tokens
or simply ignored. For example, recent versions of the \s-1GNU\s0
compiler recognize the keywords \f(CW\*(C`_\|_signed_\|_\*(C'\fR and \f(CW\*(C`_\|_extension_\|_\*(C'\fR.
The first one obviously is a synonym for \f(CW\*(C`signed\*(C'\fR, while
the second one is only a marker for a language extension.
.Sp
Using the preprocessor, you could of course do the following:
.Sp
.Vb 1
\&  $c\->Define(qw( _\|_signed_\|_=signed _\|_extension_\|_= ));
.Ve
.Sp
However, the preprocessor symbols could be undefined or
redefined in the code, and
.Sp
.Vb 3
\&  #ifdef _\|_signed_\|_
\&  # undef _\|_signed_\|_
\&  #endif
\&  
\&  typedef _\|_extension_\|_ _\|_signed_\|_ long long s_quad;
.Ve
.Sp
would generate a parse error, because \f(CW\*(C`_\|_signed_\|_\*(C'\fR is an
unexpected identifier.
.Sp
Instead of utilizing the preprocessor, you'll have to create
mappings for the new keywords directly in the parser
using \f(CW\*(C`KeywordMap\*(C'\fR. In the above example, you want to
map \f(CW\*(C`_\|_signed_\|_\*(C'\fR to the built-in C keyword \f(CW\*(C`signed\*(C'\fR and
ignore \f(CW\*(C`_\|_extension_\|_\*(C'\fR. This could be done with the following
code:
.Sp
.Vb 2
\&  $c\->KeywordMap({ _\|_signed_\|_    => \*(Aqsigned\*(Aq,
\&                   _\|_extension_\|_ => undef });
.Ve
.Sp
You can specify any valid identifier as hash key, and either
a valid C keyword or \f(CW\*(C`undef\*(C'\fR as hash value.
Having configured the object that way, you could parse even
.Sp
.Vb 3
\&  #ifdef _\|_signed_\|_
\&  # undef _\|_signed_\|_
\&  #endif
\&  
\&  typedef _\|_extension_\|_ _\|_signed_\|_ long long s_quad;
.Ve
.Sp
without problems.
.Sp
Note that \f(CW\*(C`KeywordMap\*(C'\fR and \f(CW\*(C`DisabledKeywords\*(C'\fR perfectly work
together. You could, for example, disable the \f(CW\*(C`signed\*(C'\fR keyword,
but still have \f(CW\*(C`_\|_signed_\|_\*(C'\fR mapped to the original \f(CW\*(C`signed\*(C'\fR token:
.Sp
.Vb 2
\&  $c\->configure(DisabledKeywords => [ \*(Aqsigned\*(Aq ],
\&                KeywordMap       => { _\|_signed_\|_  => \*(Aqsigned\*(Aq });
.Ve
.Sp
This would allow you to define
.Sp
.Vb 1
\&  typedef _\|_signed_\|_ long signed;
.Ve
.Sp
which would normally be a syntax error because \f(CW\*(C`signed\*(C'\fR cannot
be used as an identifier.
.ie n .IP """UnsignedChars"" => 0 | 1" 4
.el .IP "\f(CWUnsignedChars\fR => 0 | 1" 4
.IX Item "UnsignedChars => 0 | 1"
Use this boolean option if you want characters
to be unsigned if specified without an
explicit \f(CW\*(C`signed\*(C'\fR or \f(CW\*(C`unsigned\*(C'\fR type specifier.
By default, characters are signed.
.ie n .IP """UnsignedBitfields"" => 0 | 1" 4
.el .IP "\f(CWUnsignedBitfields\fR => 0 | 1" 4
.IX Item "UnsignedBitfields => 0 | 1"
Use this boolean option if you want bitfields
to be unsigned if specified without an
explicit \f(CW\*(C`signed\*(C'\fR or \f(CW\*(C`unsigned\*(C'\fR type specifier.
By default, bitfields are signed.
.ie n .IP """Warnings"" => 0 | 1" 4
.el .IP "\f(CWWarnings\fR => 0 | 1" 4
.IX Item "Warnings => 0 | 1"
Use this boolean option if you want warnings to be issued
during the parsing of source code. Currently, warnings
are only reported by the preprocessor, so don't expect
the output to cover everything.
.Sp
By default, warnings are turned off and only errors will be
reported. However, even these errors are turned off if
you run without the \f(CW\*(C`\-w\*(C'\fR flag.
.ie n .IP """HasCPPComments"" => 0 | 1" 4
.el .IP "\f(CWHasCPPComments\fR => 0 | 1" 4
.IX Item "HasCPPComments => 0 | 1"
Use this option to turn \*(C+ comments on or off. By default,
\&\*(C+ comments are enabled. Disabling \*(C+ comments may be
necessary if your code includes strange things like:
.Sp
.Vb 2
\&  one = 4 //* <\- divide */ 4;
\&  two = 2;
.Ve
.Sp
With \*(C+ comments, the above will be interpreted as
.Sp
.Vb 2
\&  one = 4
\&  two = 2;
.Ve
.Sp
which will obviously be a syntax error, but without
\&\*(C+ comments, it will be interpreted as
.Sp
.Vb 2
\&  one = 4 / 4;
\&  two = 2;
.Ve
.Sp
which is correct.
.ie n .IP """HasMacroVAARGS"" => 0 | 1" 4
.el .IP "\f(CWHasMacroVAARGS\fR => 0 | 1" 4
.IX Item "HasMacroVAARGS => 0 | 1"
Use this option to turn the \f(CW\*(C`_\|_VA_ARGS_\|_\*(C'\fR macro expansion
on or off. If this is enabled (which is the default), you can use
variable length argument lists in your preprocessor macros.
.Sp
.Vb 1
\&  #define DEBUG( ... )  fprintf( stderr, _\|_VA_ARGS_\|_ )
.Ve
.Sp
There's normally no reason to turn that feature off.
.ie n .IP """StdCVersion"" => undef | \s-1INTEGER\s0" 4
.el .IP "\f(CWStdCVersion\fR => undef | \s-1INTEGER\s0" 4
.IX Item "StdCVersion => undef | INTEGER"
Use this option to change the value of the preprocessor's
predefined \f(CW\*(C`_\|_STDC_VERSION_\|_\*(C'\fR macro. When set to \f(CW\*(C`undef\*(C'\fR,
the macro will not be defined.
.ie n .IP """HostedC"" => undef | 0 | 1" 4
.el .IP "\f(CWHostedC\fR => undef | 0 | 1" 4
.IX Item "HostedC => undef | 0 | 1"
Use this option to change the value of the preprocessor's
predefined \f(CW\*(C`_\|_STDC_HOSTED_\|_\*(C'\fR macro. When set to \f(CW\*(C`undef\*(C'\fR,
the macro will not be defined.
.ie n .IP """Include"" => [ \s-1INCLUDES \s0]" 4
.el .IP "\f(CWInclude\fR => [ \s-1INCLUDES \s0]" 4
.IX Item "Include => [ INCLUDES ]"
Use this option to set the include path for the internal
preprocessor. The option value is a reference to an array
of strings, each string holding a directory that should
be searched for includes.
.ie n .IP """Define"" => [ \s-1DEFINES \s0]" 4
.el .IP "\f(CWDefine\fR => [ \s-1DEFINES \s0]" 4
.IX Item "Define => [ DEFINES ]"
Use this option to define symbols in the preprocessor.
The option value is, again, a reference to an array of
strings. Each string can be either just a symbol or an
assignment to a symbol. This is completely equivalent
to what the \f(CW\*(C`\-D\*(C'\fR option does for most preprocessors.
.Sp
The following will define the symbol \f(CW\*(C`FOO\*(C'\fR and
define \f(CW\*(C`BAR\*(C'\fR to be \f(CW12345\fR:
.Sp
.Vb 1
\&  $c\->configure(Define => [qw( FOO BAR=12345 )]);
.Ve
.ie n .IP """Assert"" => [ \s-1ASSERTIONS \s0]" 4
.el .IP "\f(CWAssert\fR => [ \s-1ASSERTIONS \s0]" 4
.IX Item "Assert => [ ASSERTIONS ]"
Use this option to make assertions in the preprocessor.
If you don't know what assertions are, don't be
concerned, since they're deprecated anyway. They
are, however, used in some system's include files.
The value is an array reference, just like for the
macro definitions. Only the way the assertions are
defined is a bit different and mimics the way they
are defined with the \f(CW\*(C`#assert\*(C'\fR directive:
.Sp
.Vb 1
\&  $c\->configure(Assert => [\*(Aqfoo(bar)\*(Aq]);
.Ve
.ie n .IP """OrderMembers"" => 0 | 1" 4
.el .IP "\f(CWOrderMembers\fR => 0 | 1" 4
.IX Item "OrderMembers => 0 | 1"
When using \f(CW\*(C`unpack\*(C'\fR on compounds and
iterating over the returned hash, the order of the
compound members is generally not preserved due to
the nature of hash tables. It is not even guaranteed
that the order is the same between different runs of
the same program. This can be very annoying if you
simply use to dump your data structures and the
compound members always show up in a different order.
.Sp
By setting \f(CW\*(C`OrderMembers\*(C'\fR to a non-zero value, all
hashes returned by \f(CW\*(C`unpack\*(C'\fR are tied to
a class that preserves the order of the hash keys.
This way, all compound members will be returned in
the correct order just as they are defined in your C
code.
.Sp
.Vb 2
\&  use Convert::Binary::C;
\&  use Data::Dumper;
\&  
\&  $c = Convert::Binary::C\->new\->parse(<<\*(AqENDC\*(Aq);
\&  struct test {
\&    char one;
\&    char two;
\&    struct {
\&      char never;
\&      char change;
\&      char this;
\&      char order;
\&    } three;
\&    char four;
\&  };
\&  ENDC
\&  
\&  $data = "Convert";
\&  
\&  $u1 = $c\->unpack(\*(Aqtest\*(Aq, $data);
\&  $c\->OrderMembers(1);
\&  $u2 = $c\->unpack(\*(Aqtest\*(Aq, $data);
\&  
\&  print Data::Dumper\->Dump([$u1, $u2], [qw(u1 u2)]);
.Ve
.Sp
This will print something like:
.Sp
.Vb 10
\&  $u1 = {
\&    \*(Aqthree\*(Aq => {
\&      \*(Aqchange\*(Aq => 118,
\&      \*(Aqorder\*(Aq => 114,
\&      \*(Aqthis\*(Aq => 101,
\&      \*(Aqnever\*(Aq => 110
\&    },
\&    \*(Aqone\*(Aq => 67,
\&    \*(Aqtwo\*(Aq => 111,
\&    \*(Aqfour\*(Aq => 116
\&  };
\&  $u2 = {
\&    \*(Aqone\*(Aq => 67,
\&    \*(Aqtwo\*(Aq => 111,
\&    \*(Aqthree\*(Aq => {
\&      \*(Aqnever\*(Aq => 110,
\&      \*(Aqchange\*(Aq => 118,
\&      \*(Aqthis\*(Aq => 101,
\&      \*(Aqorder\*(Aq => 114
\&    },
\&    \*(Aqfour\*(Aq => 116
\&  };
.Ve
.Sp
To be able to use this option, you have to install
either the Tie::Hash::Indexed or
the Tie::IxHash module. If both are
installed, Convert::Binary::C will give preference
to Tie::Hash::Indexed because
it's faster.
.Sp
When using this option, you should keep in mind that
tied hashes are significantly slower and consume
more memory than ordinary hashes, even when the class
they're tied to is implemented efficiently. So don't
turn this option on if you don't have to.
.Sp
You can also influence hash member ordering by using
the \f(CW\*(C`CBC_ORDER_MEMBERS\*(C'\fR environment
variable.
.ie n .IP """Bitfields"" => { \s-1OPTION\s0 => \s-1VALUE, ... \s0}" 4
.el .IP "\f(CWBitfields\fR => { \s-1OPTION\s0 => \s-1VALUE, ... \s0}" 4
.IX Item "Bitfields => { OPTION => VALUE, ... }"
Use this option to specify and configure a bitfield
layouting engine. You can choose an engine by passing
its name to the \f(CW\*(C`Engine\*(C'\fR option, like:
.Sp
.Vb 1
\&  $c\->configure(Bitfields => { Engine => \*(AqGeneric\*(Aq });
.Ve
.Sp
Each engine can have its own set of options, although
currently none of them does.
.Sp
You can choose between the following bitfield engines:
.RS 4
.ie n .IP """Generic""" 4
.el .IP "\f(CWGeneric\fR" 4
.IX Item "Generic"
This engine implements the behaviour of most \s-1UNIX C\s0 compilers,
including \s-1GCC.\s0 It does not handle packed bitfields yet.
.ie n .IP """Microsoft""" 4
.el .IP "\f(CWMicrosoft\fR" 4
.IX Item "Microsoft"
This engine implements the behaviour of Microsoft's \f(CW\*(C`cl\*(C'\fR compiler.
It should be fairly complete and can handle packed bitfields.
.ie n .IP """Simple""" 4
.el .IP "\f(CWSimple\fR" 4
.IX Item "Simple"
This engine is only used for testing the bitfield infrastructure
in Convert::Binary::C. There's usually no reason to use it.
.RE
.RS 4
.RE
.RE
.RS 8
.Sp
You can reconfigure all options even after you have
parsed some code. The changes will be applied to the
already parsed definitions. This works as long as array
lengths are not affected by the changes. If you have
Alignment and IntSize set to 4 and parse code like
this
.Sp
.Vb 4
\&  typedef struct {
\&    char abc;
\&    int  day;
\&  } foo;
\&  
\&  struct bar {
\&    foo  zap[2*sizeof(foo)];
\&  };
.Ve
.Sp
the array \f(CW\*(C`zap\*(C'\fR in \f(CW\*(C`struct bar\*(C'\fR will obviously have
16 elements. If you reconfigure the alignment to 1 now,
the size of \f(CW\*(C`foo\*(C'\fR is now 5 instead of 8. While the
alignment is adjusted correctly, the number of elements
in array \f(CW\*(C`zap\*(C'\fR will still be 16 and will not be changed
to 10.
.RE
.SS "parse"
.IX Subsection "parse"
.ie n .IP """parse"" \s-1CODE\s0" 8
.el .IP "\f(CWparse\fR \s-1CODE\s0" 8
.IX Item "parse CODE"
Parses a string of valid C code. All enumeration, compound
and type definitions are extracted. You can call
the \f(CW\*(C`parse\*(C'\fR and \f(CW\*(C`parse_file\*(C'\fR methods
as often as you like to add further definitions to the
Convert::Binary::C object.
.Sp
\&\f(CW\*(C`parse\*(C'\fR will throw an exception if an error occurs.
On success, the method returns a reference to its object.
.Sp
See \*(L"Parsing C code\*(R" for an example.
.SS "parse_file"
.IX Subsection "parse_file"
.ie n .IP """parse_file"" \s-1FILE\s0" 8
.el .IP "\f(CWparse_file\fR \s-1FILE\s0" 8
.IX Item "parse_file FILE"
Parses a C source file. All enumeration, compound and type
definitions are extracted. You can call
the \f(CW\*(C`parse\*(C'\fR and \f(CW\*(C`parse_file\*(C'\fR methods
as often as you like to add further definitions to the
Convert::Binary::C object.
.Sp
\&\f(CW\*(C`parse_file\*(C'\fR will search the include path given
via the \f(CW\*(C`Include\*(C'\fR option for the file if it cannot find it in the
current directory.
.Sp
\&\f(CW\*(C`parse_file\*(C'\fR will throw an exception if an error
occurs. On success, the method returns a reference to its object.
.Sp
See \*(L"Parsing C code\*(R" for an example.
.Sp
When calling \f(CW\*(C`parse\*(C'\fR or \f(CW\*(C`parse_file\*(C'\fR multiple
times, you may use types previously defined, but you are not allowed
to redefine types. The state of the preprocessor is also saved, so you
may also use defines from a previous parse. This works only as long as the
preprocessor is not reset. See \*(L"Preprocessor configuration\*(R" for details.
.Sp
When you're parsing C source files instead of C header
files, note that local definitions are ignored. This means
that type definitions hidden within functions will not be
recognized by Convert::Binary::C. This is necessary
because different functions (even different blocks within
the same function) can define types with the same name:
.Sp
.Vb 10
\&  void my_func(int i)
\&  {
\&    if (i < 10)
\&    {
\&      enum digit { ONE, TWO, THREE } x = ONE;
\&      printf("%d, %d\en", i, x);
\&    }
\&    else
\&    {
\&      enum digit { THREE, TWO, ONE } x = ONE;
\&      printf("%d, %d\en", i, x);
\&    }
\&  }
.Ve
.Sp
The above is a valid piece of C code, but it's not possible
for Convert::Binary::C to distinguish between the different
definitions of \f(CW\*(C`enum digit\*(C'\fR, as they're only defined
locally within the corresponding block.
.SS "clean"
.IX Subsection "clean"
.ie n .IP """clean""" 8
.el .IP "\f(CWclean\fR" 8
.IX Item "clean"
Clears all information that has been collected during previous
calls to \f(CW\*(C`parse\*(C'\fR or \f(CW\*(C`parse_file\*(C'\fR.
You can use this method if you want to parse some entirely
different code, but with the same configuration.
.Sp
The \f(CW\*(C`clean\*(C'\fR method returns a reference to its object.
.SS "clone"
.IX Subsection "clone"
.ie n .IP """clone""" 8
.el .IP "\f(CWclone\fR" 8
.IX Item "clone"
Makes the object return an exact independent copy of itself.
.Sp
.Vb 3
\&  $c = new Convert::Binary::C Include => [\*(Aq/usr/include\*(Aq];
\&  $c\->parse_file(\*(Aqdefinitions.c\*(Aq);
\&  $clone = $c\->clone;
.Ve
.Sp
The above code is technically equivalent (Mostly. Actually,
using \f(CW\*(C`sourcify\*(C'\fR and \f(CW\*(C`parse\*(C'\fR might alter
the order of the parsed data, which would make methods such
as \f(CW\*(C`compound\*(C'\fR return the definitions in a different
order.) to:
.Sp
.Vb 4
\&  $c = new Convert::Binary::C Include => [\*(Aq/usr/include\*(Aq];
\&  $c\->parse_file(\*(Aqdefinitions.c\*(Aq);
\&  $clone = new Convert::Binary::C %{$c\->configure};
\&  $clone\->parse($c\->sourcify);
.Ve
.Sp
Using \f(CW\*(C`clone\*(C'\fR is just a lot faster.
.SS "def"
.IX Subsection "def"
.ie n .IP """def"" \s-1NAME\s0" 8
.el .IP "\f(CWdef\fR \s-1NAME\s0" 8
.IX Item "def NAME"
.PD 0
.ie n .IP """def"" \s-1TYPE\s0" 8
.el .IP "\f(CWdef\fR \s-1TYPE\s0" 8
.IX Item "def TYPE"
.PD
If you need to know if a definition for a certain type name
exists, use this method. You pass it the name of an enum,
struct, union or typedef, and it will return a non-empty
string being either \f(CW"enum"\fR, \f(CW"struct"\fR, \f(CW"union"\fR,
or \f(CW"typedef"\fR if there's a definition for the type in
question, an empty string if there's no such definition,
or \f(CW\*(C`undef\*(C'\fR if the name is completely unknown. If the
type can be interpreted as a basic type, \f(CW"basic"\fR will
be returned.
.Sp
If you pass in a \s-1TYPE\s0, the output
will be slightly different. If the specified member exists,
the \f(CW\*(C`def\*(C'\fR method will return \f(CW"member"\fR. If the
member doesn't exist, or if the type cannot have members, the
empty string will be returned. Again, if the name of the type
is completely unknown, \f(CW\*(C`undef\*(C'\fR will be returned. This may be
useful if you want to check if a certain member exists within
a compound, for example.
.Sp
.Vb 1
\&  use Convert::Binary::C;
\&  
\&  my $c = Convert::Binary::C\->new\->parse(<<\*(AqENDC\*(Aq);
\&  
\&  typedef struct _\|_not  not;
\&  typedef struct _\|_not *ptr;
\&  
\&  struct foo {
\&    enum bar *xxx;
\&  };
\&  
\&  typedef int quad[4];
\&  
\&  ENDC
\&  
\&  for my $type (qw( not ptr foo bar xxx foo.xxx foo.abc xxx.yyy
\&                    quad quad[3] quad[5] quad[\-3] short[1] ),
\&                \*(Aqunsigned long\*(Aq)
\&  {
\&    my $def = $c\->def($type);
\&    printf "%\-14s  =>  %s\en",
\&            $type,     defined $def ? "\*(Aq$def\*(Aq" : \*(Aqundef\*(Aq;
\&  }
.Ve
.Sp
The following would be returned by the \f(CW\*(C`def\*(C'\fR method:
.Sp
.Vb 10
\&  not             =>  \*(Aq\*(Aq
\&  ptr             =>  \*(Aqtypedef\*(Aq
\&  foo             =>  \*(Aqstruct\*(Aq
\&  bar             =>  \*(Aq\*(Aq
\&  xxx             =>  undef
\&  foo.xxx         =>  \*(Aqmember\*(Aq
\&  foo.abc         =>  \*(Aq\*(Aq
\&  xxx.yyy         =>  undef
\&  quad            =>  \*(Aqtypedef\*(Aq
\&  quad[3]         =>  \*(Aqmember\*(Aq
\&  quad[5]         =>  \*(Aqmember\*(Aq
\&  quad[\-3]        =>  \*(Aqmember\*(Aq
\&  short[1]        =>  undef
\&  unsigned long   =>  \*(Aqbasic\*(Aq
.Ve
.Sp
So, if \f(CW\*(C`def\*(C'\fR returns a non-empty string, you can safely use
any other method with that type's name or with that member expression.
.Sp
Concerning arrays, note that the index into an array doesn't
need to be within the bounds of the array's definition, just
like in C. In the above example, \f(CW\*(C`quad[5]\*(C'\fR and \f(CW\*(C`quad[\-3]\*(C'\fR are
valid members of the \f(CW\*(C`quad\*(C'\fR array, even though it is declared to
have only four elements.
.Sp
In cases where the typedef namespace overlaps with the
namespace of enums/structs/unions, the \f(CW\*(C`def\*(C'\fR method
will give preference to the typedef and will thus return
the string \f(CW"typedef"\fR. You could however force interpretation
as an enum, struct or union by putting \f(CW"enum"\fR, \f(CW"struct"\fR
or \f(CW"union"\fR in front of the type's name.
.SS "defined"
.IX Subsection "defined"
.ie n .IP """defined"" \s-1MACRO\s0" 8
.el .IP "\f(CWdefined\fR \s-1MACRO\s0" 8
.IX Item "defined MACRO"
You can use the \f(CW\*(C`defined\*(C'\fR method to find out if a certain
macro is defined, just like you would use the \f(CW\*(C`defined\*(C'\fR operator of the
preprocessor. For example, the following code
.Sp
.Vb 1
\&  use Convert::Binary::C;
\&  
\&  my $c = Convert::Binary::C\->new\->parse(<<\*(AqENDC\*(Aq);
\&  
\&  #define ADD(a, b) ((a) + (b))
\&  
\&  #if 1
\&  # define DEFINED
\&  #else
\&  # define UNDEFINED
\&  #endif
\&  
\&  ENDC
\&  
\&  for my $macro (qw( ADD DEFINED UNDEFINED )) {
\&    my $not = $c\->defined($macro) ? \*(Aq\*(Aq : \*(Aq not\*(Aq;
\&    print "Macro \*(Aq$macro\*(Aq is$not defined.\en";
\&  }
.Ve
.Sp
would print:
.Sp
.Vb 3
\&  Macro \*(AqADD\*(Aq is defined.
\&  Macro \*(AqDEFINED\*(Aq is defined.
\&  Macro \*(AqUNDEFINED\*(Aq is not defined.
.Ve
.Sp
You have to keep in mind that this works only as long as the preprocessor
is not reset. See \*(L"Preprocessor configuration\*(R" for details.
.SS "pack"
.IX Subsection "pack"
.ie n .IP """pack"" \s-1TYPE\s0" 8
.el .IP "\f(CWpack\fR \s-1TYPE\s0" 8
.IX Item "pack TYPE"
.PD 0
.ie n .IP """pack"" \s-1TYPE, DATA\s0" 8
.el .IP "\f(CWpack\fR \s-1TYPE, DATA\s0" 8
.IX Item "pack TYPE, DATA"
.ie n .IP """pack"" \s-1TYPE, DATA, STRING\s0" 8
.el .IP "\f(CWpack\fR \s-1TYPE, DATA, STRING\s0" 8
.IX Item "pack TYPE, DATA, STRING"
.PD
Use this method to pack a complex data structure into a
binary string according to a type definition that has been
previously parsed. \s-1DATA\s0 must be a scalar matching the
type definition. C structures and unions are represented
by references to Perl hashes, C arrays by references to
Perl arrays.
.Sp
.Vb 3
\&  use Convert::Binary::C;
\&  use Data::Dumper;
\&  use Data::Hexdumper;
\&  
\&  $c = Convert::Binary::C\->new( ByteOrder => \*(AqBigEndian\*(Aq
\&                              , LongSize  => 4
\&                              , ShortSize => 2
\&                              )
\&                         \->parse(<<\*(AqENDC\*(Aq);
\&  struct test {
\&    char    ary[3];
\&    union {
\&      short word[2];
\&      long  quad;
\&    }       uni;
\&  };
\&  ENDC
.Ve
.Sp
Hashes don't have to contain a key for each compound member
and arrays may be truncated:
.Sp
.Vb 1
\&  $binary = $c\->pack(\*(Aqtest\*(Aq, { ary => [1, 2], uni => { quad => 42 } });
.Ve
.Sp
Elements not defined in the Perl data structure will be
set to zero in the packed byte string. If you pass \f(CW\*(C`undef\*(C'\fR as
or simply omit the second parameter, the whole string will be
initialized with zero bytes. On success, the packed byte
string is returned.
.Sp
.Vb 1
\&  print hexdump(data => $binary);
.Ve
.Sp
The above code would print:
.Sp
.Vb 1
\&    0x0000 : 01 02 00 00 00 00 2A                            : ......*
.Ve
.Sp
You could also use \f(CW\*(C`unpack\*(C'\fR and dump the data structure.
.Sp
.Vb 2
\&  $unpacked = $c\->unpack(\*(Aqtest\*(Aq, $binary);
\&  print Data::Dumper\->Dump([$unpacked], [\*(Aqunpacked\*(Aq]);
.Ve
.Sp
This would print:
.Sp
.Vb 10
\&  $unpacked = {
\&    \*(Aquni\*(Aq => {
\&      \*(Aqword\*(Aq => [
\&        0,
\&        42
\&      ],
\&      \*(Aqquad\*(Aq => 42
\&    },
\&    \*(Aqary\*(Aq => [
\&      1,
\&      2,
\&      0
\&    ]
\&  };
.Ve
.Sp
If \s-1TYPE\s0 refers to a compound object,
you may pack any member of that compound object. Simply add
a member expression to the type
name, just as you would access the member in C:
.Sp
.Vb 2
\&  $array = $c\->pack(\*(Aqtest.ary\*(Aq, [1, 2, 3]);
\&  print hexdump(data => $array);
\&  
\&  $value = $c\->pack(\*(Aqtest.uni.word[1]\*(Aq, 2);
\&  print hexdump(data => $value);
.Ve
.Sp
This would give you:
.Sp
.Vb 2
\&    0x0000 : 01 02 03                                        : ...
\&    0x0000 : 00 02                                           : ..
.Ve
.Sp
Call \f(CW\*(C`pack\*(C'\fR with the optional \s-1STRING\s0 argument if you want
to use an existing binary string to insert the data.
If called in a void context, \f(CW\*(C`pack\*(C'\fR will directly
modify the string you passed as the third argument.
Otherwise, a copy of the string is created, and \f(CW\*(C`pack\*(C'\fR will
modify and return the copy, so the original string
will remain unchanged.
.Sp
The 3\-argument version may be useful if you want to change
only a few members of a complex data structure without
having to \f(CW\*(C`unpack\*(C'\fR everything, change the members, and
then \f(CW\*(C`pack\*(C'\fR again (which could waste lots of memory
and \s-1CPU\s0 cycles). So, instead of doing something like
.Sp
.Vb 3
\&  $test = $c\->unpack(\*(Aqtest\*(Aq, $binary);
\&  $test\->{uni}{quad} = 4711;
\&  $new = $c\->pack(\*(Aqtest\*(Aq, $test);
.Ve
.Sp
to change the \f(CW\*(C`uni.quad\*(C'\fR member of \f(CW$packed\fR, you
could simply do either
.Sp
.Vb 1
\&  $new = $c\->pack(\*(Aqtest\*(Aq, { uni => { quad => 4711 } }, $binary);
.Ve
.Sp
or
.Sp
.Vb 1
\&  $c\->pack(\*(Aqtest\*(Aq, { uni => { quad => 4711 } }, $binary);
.Ve
.Sp
while the latter would directly modify \f(CW$packed\fR.
Besides this code being a lot shorter (and perhaps even
more readable), it can be significantly faster if you're
dealing with really big data blocks.
.Sp
If the length of the input string is less than the size
required by the type, the string (or its copy) is
extended and the extended part is initialized to zero.
If the length is more than the size required by the type,
the string is kept at that length, and also a copy would
be an exact copy of that string.
.Sp
.Vb 2
\&  $too_short = pack "C*", (1 .. 4);
\&  $too_long  = pack "C*", (1 .. 20);
\&  
\&  $c\->pack(\*(Aqtest\*(Aq, { uni => { quad => 0x4711 } }, $too_short);
\&  print "too_short:\en", hexdump(data => $too_short);
\&  
\&  $copy = $c\->pack(\*(Aqtest\*(Aq, { uni => { quad => 0x4711 } }, $too_long);
\&  print "\encopy:\en", hexdump(data => $copy);
.Ve
.Sp
This would print:
.Sp
.Vb 2
\&  too_short:
\&    0x0000 : 01 02 03 00 00 47 11                            : .....G.
\&  
\&  copy:
\&    0x0000 : 01 02 03 00 00 47 11 08 09 0A 0B 0C 0D 0E 0F 10 : .....G..........
\&    0x0010 : 11 12 13 14                                     : ....
.Ve
.SS "unpack"
.IX Subsection "unpack"
.ie n .IP """unpack"" \s-1TYPE, STRING\s0" 8
.el .IP "\f(CWunpack\fR \s-1TYPE, STRING\s0" 8
.IX Item "unpack TYPE, STRING"
Use this method to unpack a binary string and create an
arbitrarily complex Perl data structure based on a
previously parsed type definition.
.Sp
.Vb 2
\&  use Convert::Binary::C;
\&  use Data::Dumper;
\&  
\&  $c = Convert::Binary::C\->new( ByteOrder => \*(AqBigEndian\*(Aq
\&                              , LongSize  => 4
\&                              , ShortSize => 2
\&                              )
\&                         \->parse( <<\*(AqENDC\*(Aq );
\&  struct test {
\&    char    ary[3];
\&    union {
\&      short word[2];
\&      long *quad;
\&    }       uni;
\&  };
\&  ENDC
\&  
\&  # Generate some binary dummy data
\&  $binary = pack "C*", 1 .. $c\->sizeof(\*(Aqtest\*(Aq);
.Ve
.Sp
On failure, e.g. if the specified type cannot be found, the
method will throw an exception. On success, a reference to
a complex Perl data structure is returned, which can directly
be dumped using the Data::Dumper module:
.Sp
.Vb 2
\&  $unpacked = $c\->unpack(\*(Aqtest\*(Aq, $binary);
\&  print Dumper($unpacked);
.Ve
.Sp
This would print:
.Sp
.Vb 10
\&  $VAR1 = {
\&    \*(Aquni\*(Aq => {
\&      \*(Aqword\*(Aq => [
\&        1029,
\&        1543
\&      ],
\&      \*(Aqquad\*(Aq => 67438087
\&    },
\&    \*(Aqary\*(Aq => [
\&      1,
\&      2,
\&      3
\&    ]
\&  };
.Ve
.Sp
If \s-1TYPE\s0 refers to a compound object,
you may unpack any member of that compound object. Simply add
a member expression to the type
name, just as you would access the member in C:
.Sp
.Vb 1
\&  $binary2 = substr $binary, $c\->offsetof(\*(Aqtest\*(Aq, \*(Aquni.word\*(Aq);
\&  
\&  $unpack1 = $unpacked\->{uni}{word};
\&  $unpack2 = $c\->unpack(\*(Aqtest.uni.word\*(Aq, $binary2);
\&  
\&  print Data::Dumper\->Dump([$unpack1, $unpack2], [qw(unpack1 unpack2)]);
.Ve
.Sp
You will find that the output is exactly the same for
both \f(CW$unpack1\fR and \f(CW$unpack2\fR:
.Sp
.Vb 8
\&  $unpack1 = [
\&    1029,
\&    1543
\&  ];
\&  $unpack2 = [
\&    1029,
\&    1543
\&  ];
.Ve
.Sp
When \f(CW\*(C`unpack\*(C'\fR is called in list context, it will
unpack as many elements as possible from \s-1STRING,\s0 including zero
if \s-1STRING\s0 is not long enough.
.SS "initializer"
.IX Subsection "initializer"
.ie n .IP """initializer"" \s-1TYPE\s0" 8
.el .IP "\f(CWinitializer\fR \s-1TYPE\s0" 8
.IX Item "initializer TYPE"
.PD 0
.ie n .IP """initializer"" \s-1TYPE, DATA\s0" 8
.el .IP "\f(CWinitializer\fR \s-1TYPE, DATA\s0" 8
.IX Item "initializer TYPE, DATA"
.PD
The \f(CW\*(C`initializer\*(C'\fR method can be used retrieve
an initializer string for a certain \s-1TYPE\s0.
This can be useful if you have to initialize only a couple of
members in a huge compound type or if you simply want to generate
initializers automatically.
.Sp
.Vb 7
\&  struct date {
\&    unsigned year : 12;
\&    unsigned month:  4;
\&    unsigned day  :  5;
\&    unsigned hour :  5;
\&    unsigned min  :  6;
\&  };
\&  
\&  typedef struct {
\&    enum { DATE, QWORD } type;
\&    short number;
\&    union {
\&      struct date   date;
\&      unsigned long qword;
\&    } choice;
\&  } data;
.Ve
.Sp
Given the above code has been parsed
.Sp
.Vb 2
\&  $init = $c\->initializer(\*(Aqdata\*(Aq);
\&  print "data x = $init;\en";
.Ve
.Sp
would print the following:
.Sp
.Vb 10
\&  data x = {
\&        0,
\&        0,
\&        {
\&                {
\&                        0,
\&                        0,
\&                        0,
\&                        0,
\&                        0
\&                }
\&        }
\&  };
.Ve
.Sp
You could directly put that into a C program, although it probably
isn't very useful yet. It becomes more useful if you actually specify
how you want to initialize the type:
.Sp
.Vb 8
\&  $data = {
\&    type   => \*(AqQWORD\*(Aq,
\&    choice => {
\&      date  => { month => 12, day => 24 },
\&      qword => 4711,
\&    },
\&    stuff => \*(Aqyes?\*(Aq,
\&  };
\&  
\&  $init = $c\->initializer(\*(Aqdata\*(Aq, $data);
\&  print "data x = $init;\en";
.Ve
.Sp
This would print the following:
.Sp
.Vb 10
\&  data x = {
\&        QWORD,
\&        0,
\&        {
\&                {
\&                        0,
\&                        12,
\&                        24,
\&                        0,
\&                        0
\&                }
\&        }
\&  };
.Ve
.Sp
As only the first member of a \f(CW\*(C`union\*(C'\fR can be initialized, \f(CW\*(C`choice.qword\*(C'\fR is
ignored. You will not be warned about the fact that you probably tried
to initialize a member other than the first. This is considered
a feature, because it allows you to use \f(CW\*(C`unpack\*(C'\fR to generate
the initializer data:
.Sp
.Vb 2
\&  $data = $c\->unpack(\*(Aqdata\*(Aq, $binary);
\&  $init = $c\->initializer(\*(Aqdata\*(Aq, $data);
.Ve
.Sp
Since \f(CW\*(C`unpack\*(C'\fR unpacks all union members, you would
otherwise have to delete all but the first one previous to feeding
it into \f(CW\*(C`initializer\*(C'\fR.
.Sp
Also, \f(CW\*(C`stuff\*(C'\fR is ignored, because it actually isn't a member
of \f(CW\*(C`data\*(C'\fR. You won't be warned about that either.
.SS "sizeof"
.IX Subsection "sizeof"
.ie n .IP """sizeof"" \s-1TYPE\s0" 8
.el .IP "\f(CWsizeof\fR \s-1TYPE\s0" 8
.IX Item "sizeof TYPE"
This method will return the size of a C type in bytes.
If it cannot find the type, it will throw an exception.
.Sp
If the type defines some kind of compound object, you may
ask for the size of a member of
that compound object:
.Sp
.Vb 1
\&  $size = $c\->sizeof(\*(Aqtest.uni.word[1]\*(Aq);
.Ve
.Sp
This would set \f(CW$size\fR to \f(CW2\fR.
.SS "typeof"
.IX Subsection "typeof"
.ie n .IP """typeof"" \s-1TYPE\s0" 8
.el .IP "\f(CWtypeof\fR \s-1TYPE\s0" 8
.IX Item "typeof TYPE"
This method will return the type of a C member.
While this only makes sense for compound types, it's legal
to also use it for non-compound types.
If it cannot find the type, it will throw an exception.
.Sp
The \f(CW\*(C`typeof\*(C'\fR method can be used on any
valid member, even on arrays or
unnamed types. It will always return a string that holds
the name (or in case of unnamed types only the class) of
the type, optionally followed by a \f(CW\*(Aq*\*(Aq\fR character to
indicate it's a pointer type, and optionally followed by
one or more array dimensions if it's an array type. If
the type is a bitfield, the type name is followed by a
colon and the number of bits.
.Sp
.Vb 11
\&  struct test {
\&    char    ary[3];
\&    union {
\&      short word[2];
\&      long *quad;
\&    }       uni;
\&    struct {
\&      unsigned short six:6;
\&      unsigned short ten:10;
\&    }       bits;
\&  };
.Ve
.Sp
Given the above C code has been parsed, calls
to \f(CW\*(C`typeof\*(C'\fR would return the following
values:
.Sp
.Vb 9
\&  $c\->typeof(\*(Aqtest\*(Aq)             => \*(Aqstruct test\*(Aq
\&  $c\->typeof(\*(Aqtest.ary\*(Aq)         => \*(Aqchar [3]\*(Aq
\&  $c\->typeof(\*(Aqtest.uni\*(Aq)         => \*(Aqunion\*(Aq
\&  $c\->typeof(\*(Aqtest.uni.quad\*(Aq)    => \*(Aqlong *\*(Aq
\&  $c\->typeof(\*(Aqtest.uni.word\*(Aq)    => \*(Aqshort [2]\*(Aq
\&  $c\->typeof(\*(Aqtest.uni.word[1]\*(Aq) => \*(Aqshort\*(Aq
\&  $c\->typeof(\*(Aqtest.bits\*(Aq)        => \*(Aqstruct\*(Aq
\&  $c\->typeof(\*(Aqtest.bits.six\*(Aq)    => \*(Aqunsigned short :6\*(Aq
\&  $c\->typeof(\*(Aqtest.bits.ten\*(Aq)    => \*(Aqunsigned short :10\*(Aq
.Ve
.SS "offsetof"
.IX Subsection "offsetof"
.ie n .IP """offsetof"" \s-1TYPE, MEMBER\s0" 8
.el .IP "\f(CWoffsetof\fR \s-1TYPE, MEMBER\s0" 8
.IX Item "offsetof TYPE, MEMBER"
You can use \f(CW\*(C`offsetof\*(C'\fR just like the C macro
of same denominator. It will simply return the offset (in bytes)
of \s-1MEMBER\s0 relative to \s-1TYPE\s0.
.Sp
.Vb 1
\&  use Convert::Binary::C;
\&  
\&  $c = Convert::Binary::C\->new( Alignment   => 4
\&                              , LongSize    => 4
\&                              , PointerSize => 4
\&                              )
\&                         \->parse(<<\*(AqENDC\*(Aq);
\&  typedef struct {
\&    char abc;
\&    long day;
\&    int *ptr;
\&  } week;
\&  
\&  struct test {
\&    week zap[8];
\&  };
\&  ENDC
\&  
\&  @args = (
\&    [\*(Aqtest\*(Aq,        \*(Aqzap[5].day\*(Aq  ],
\&    [\*(Aqtest.zap[2]\*(Aq, \*(Aqday\*(Aq         ],
\&    [\*(Aqtest\*(Aq,        \*(Aqzap[5].day+1\*(Aq],
\&    [\*(Aqtest\*(Aq,        \*(Aqzap[\-3].ptr\*(Aq ],
\&  );
\&  
\&  for (@args) {
\&    my $offset = eval { $c\->offsetof(@$_) };
\&    printf "\e$c\->offsetof(\*(Aq%s\*(Aq, \*(Aq%s\*(Aq) => $offset\en", @$_;
\&  }
.Ve
.Sp
The final loop will print:
.Sp
.Vb 4
\&  $c\->offsetof(\*(Aqtest\*(Aq, \*(Aqzap[5].day\*(Aq) => 64
\&  $c\->offsetof(\*(Aqtest.zap[2]\*(Aq, \*(Aqday\*(Aq) => 4
\&  $c\->offsetof(\*(Aqtest\*(Aq, \*(Aqzap[5].day+1\*(Aq) => 65
\&  $c\->offsetof(\*(Aqtest\*(Aq, \*(Aqzap[\-3].ptr\*(Aq) => \-28
.Ve
.RS 8
.IP "\(bu" 2
The first iteration simply shows that the offset
of \f(CW\*(C`zap[5].day\*(C'\fR is 64 relative to the beginning
of \f(CW\*(C`struct test\*(C'\fR.
.IP "\(bu" 2
You may additionally specify a member for the type
passed as the first argument, as shown in the second
iteration.
.IP "\(bu" 2
The offset suffix is also supported
by \f(CW\*(C`offsetof\*(C'\fR, so the third iteration
will correctly print 65.
.IP "\(bu" 2
The last iteration demonstrates that even out-of-bounds
array indices are handled correctly, just as they are
handled in C.
.RE
.RS 8
.Sp
Unlike the C macro, \f(CW\*(C`offsetof\*(C'\fR also works
on array types.
.Sp
.Vb 2
\&  $offset = $c\->offsetof(\*(Aqtest.zap\*(Aq, \*(Aq[3].ptr+2\*(Aq);
\&  print "offset = $offset";
.Ve
.Sp
This will print:
.Sp
.Vb 1
\&  offset = 46
.Ve
.Sp
If \s-1TYPE\s0 is a
compound, \s-1MEMBER\s0 may
optionally be prefixed with a dot, so
.Sp
.Vb 2
\&  printf "offset = %d\en", $c\->offsetof(\*(Aqweek\*(Aq, \*(Aqday\*(Aq);
\&  printf "offset = %d\en", $c\->offsetof(\*(Aqweek\*(Aq, \*(Aq.day\*(Aq);
.Ve
.Sp
are both equivalent and will print
.Sp
.Vb 2
\&  offset = 4
\&  offset = 4
.Ve
.Sp
This allows one to
.IP "\(bu" 2
use the C macro style, without a leading dot, and
.IP "\(bu" 2
directly use the output of the \f(CW\*(C`member\*(C'\fR method,
which includes a leading dot for compound types, as input for
the \s-1MEMBER\s0 argument.
.RE
.RS 8
.RE
.SS "member"
.IX Subsection "member"
.ie n .IP """member"" \s-1TYPE\s0" 8
.el .IP "\f(CWmember\fR \s-1TYPE\s0" 8
.IX Item "member TYPE"
.PD 0
.ie n .IP """member"" \s-1TYPE, OFFSET\s0" 8
.el .IP "\f(CWmember\fR \s-1TYPE, OFFSET\s0" 8
.IX Item "member TYPE, OFFSET"
.PD
You can think of \f(CW\*(C`member\*(C'\fR as being the reverse
of the \f(CW\*(C`offsetof\*(C'\fR method. However, as this is
more complex, there's no equivalent to \f(CW\*(C`member\*(C'\fR in
the C language.
.Sp
Usually this method is used if you want to retrieve the name of
the member that is located at a specific offset of a previously
parsed type.
.Sp
.Vb 1
\&  use Convert::Binary::C;
\&  
\&  $c = Convert::Binary::C\->new( Alignment   => 4
\&                              , LongSize    => 4
\&                              , PointerSize => 4
\&                              )
\&                         \->parse(<<\*(AqENDC\*(Aq);
\&  typedef struct {
\&    char abc;
\&    long day;
\&    int *ptr;
\&  } week;
\&  
\&  struct test {
\&    week zap[8];
\&  };
\&  ENDC
\&  
\&  for my $offset (24, 39, 69, 99) {
\&    print "\e$c\->member(\*(Aqtest\*(Aq, $offset)";
\&    my $member = eval { $c\->member(\*(Aqtest\*(Aq, $offset) };
\&    print $@ ? "\en  exception: $@" : " => \*(Aq$member\*(Aq\en";
\&  }
.Ve
.Sp
This will print:
.Sp
.Vb 5
\&  $c\->member(\*(Aqtest\*(Aq, 24) => \*(Aq.zap[2].abc\*(Aq
\&  $c\->member(\*(Aqtest\*(Aq, 39) => \*(Aq.zap[3]+3\*(Aq
\&  $c\->member(\*(Aqtest\*(Aq, 69) => \*(Aq.zap[5].ptr+1\*(Aq
\&  $c\->member(\*(Aqtest\*(Aq, 99)
\&    exception: Offset 99 out of range (0 <= offset < 96)
.Ve
.RS 8
.IP "\(bu" 2
The output of the first iteration is obvious. The
member \f(CW\*(C`zap[2].abc\*(C'\fR is located at offset 24 of \f(CW\*(C`struct test\*(C'\fR.
.IP "\(bu" 2
In the second iteration, the offset points into a region
of padding bytes and thus no member of \f(CW\*(C`week\*(C'\fR can be
named. Instead of a member name the offset relative
to \f(CW\*(C`zap[3]\*(C'\fR is appended.
.IP "\(bu" 2
In the third iteration, the offset points to \f(CW\*(C`zap[5].ptr\*(C'\fR.
However, \f(CW\*(C`zap[5].ptr\*(C'\fR is located at 68, not at 69,
and thus the remaining offset of 1 is also appended.
.IP "\(bu" 2
The last iteration causes an exception because the offset
of 99 is not valid for \f(CW\*(C`struct test\*(C'\fR since the size
of \f(CW\*(C`struct test\*(C'\fR is only 96. You might argue that this is
inconsistent, since \f(CW\*(C`offsetof\*(C'\fR can also handle
out-of-bounds array members. But as soon as you have more
than one level of array nesting, there's an infinite number
of out-of-bounds members for a single given offset, so it
would be impossible to return a list of all members.
.RE
.RS 8
.Sp
You can additionally specify a member for the type passed
as the first argument:
.Sp
.Vb 2
\&  $member = $c\->member(\*(Aqtest.zap[2]\*(Aq, 6);
\&  print $member;
.Ve
.Sp
This will print:
.Sp
.Vb 1
\&  .day+2
.Ve
.Sp
Like \f(CW\*(C`offsetof\*(C'\fR, \f(CW\*(C`member\*(C'\fR also
works on array types:
.Sp
.Vb 2
\&  $member = $c\->member(\*(Aqtest.zap\*(Aq, 42);
\&  print $member;
.Ve
.Sp
This will print:
.Sp
.Vb 1
\&  [3].day+2
.Ve
.Sp
While the behaviour for \f(CW\*(C`struct\*(C'\fRs is quite obvious, the behaviour
for \f(CW\*(C`union\*(C'\fRs is rather tricky. As a single offset usually references
more than one member of a union, there are certain rules that the
algorithm uses for determining the \fIbest\fR member.
.IP "\(bu" 2
The first non-compound member that is referenced without an offset
has the highest priority.
.IP "\(bu" 2
If no member is referenced without an offset, the first non-compound
member that is referenced with an offset will be returned.
.IP "\(bu" 2
Otherwise the first padding region that is encountered will be taken.
.RE
.RS 8
.Sp
As an example, given 4\-byte\-alignment and the union
.Sp
.Vb 12
\&  union choice {
\&    struct {
\&      char  color[2];
\&      long  size;
\&      char  taste;
\&    }       apple;
\&    char    grape[3];
\&    struct {
\&      long  weight;
\&      short price[3];
\&    }       melon;
\&  };
.Ve
.Sp
the \f(CW\*(C`member\*(C'\fR method would return what is shown in
the \fIMember\fR column of the following table. The \fIType\fR column
shows the result of the \f(CW\*(C`typeof\*(C'\fR method when passing
the corresponding member.
.Sp
.Vb 10
\&  Offset   Member               Type
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     0     .apple.color[0]      \*(Aqchar\*(Aq
\&     1     .apple.color[1]      \*(Aqchar\*(Aq
\&     2     .grape[2]            \*(Aqchar\*(Aq
\&     3     .melon.weight+3      \*(Aqlong\*(Aq
\&     4     .apple.size          \*(Aqlong\*(Aq
\&     5     .apple.size+1        \*(Aqlong\*(Aq
\&     6     .melon.price[1]      \*(Aqshort\*(Aq
\&     7     .apple.size+3        \*(Aqlong\*(Aq
\&     8     .apple.taste         \*(Aqchar\*(Aq
\&     9     .melon.price[2]+1    \*(Aqshort\*(Aq
\&    10     .apple+10            \*(Aqstruct\*(Aq
\&    11     .apple+11            \*(Aqstruct\*(Aq
.Ve
.Sp
It's like having a stack of all the union members and looking through
the stack for the shiniest piece you can see. The beginning of a member
(denoted by uppercase letters) is always shinier than the rest of a
member, while padding regions (denoted by dashes) aren't shiny at all.
.Sp
.Vb 5
\&  Offset   0   1   2   3   4   5   6   7   8   9  10  11
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  apple   (C) (C)  \-   \-  (S) (s)  s  (s) (T)  \-  (\-) (\-)
\&  grape    G   G  (G)
\&  melon    W   w   w  (w)  P   p  (P)  p   P  (p)  \-   \-
.Ve
.Sp
If you look through that stack from top to bottom, you'll end up at
the parenthesized members.
.Sp
Alternatively, if you're not only interested in the \fIbest\fR member,
you can call \f(CW\*(C`member\*(C'\fR in list context, which makes it
return \fIall\fR members referenced by the given offset.
.Sp
.Vb 10
\&  Offset   Member               Type
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     0     .apple.color[0]      \*(Aqchar\*(Aq
\&           .grape[0]            \*(Aqchar\*(Aq
\&           .melon.weight        \*(Aqlong\*(Aq
\&     1     .apple.color[1]      \*(Aqchar\*(Aq
\&           .grape[1]            \*(Aqchar\*(Aq
\&           .melon.weight+1      \*(Aqlong\*(Aq
\&     2     .grape[2]            \*(Aqchar\*(Aq
\&           .melon.weight+2      \*(Aqlong\*(Aq
\&           .apple+2             \*(Aqstruct\*(Aq
\&     3     .melon.weight+3      \*(Aqlong\*(Aq
\&           .apple+3             \*(Aqstruct\*(Aq
\&     4     .apple.size          \*(Aqlong\*(Aq
\&           .melon.price[0]      \*(Aqshort\*(Aq
\&     5     .apple.size+1        \*(Aqlong\*(Aq
\&           .melon.price[0]+1    \*(Aqshort\*(Aq
\&     6     .melon.price[1]      \*(Aqshort\*(Aq
\&           .apple.size+2        \*(Aqlong\*(Aq
\&     7     .apple.size+3        \*(Aqlong\*(Aq
\&           .melon.price[1]+1    \*(Aqshort\*(Aq
\&     8     .apple.taste         \*(Aqchar\*(Aq
\&           .melon.price[2]      \*(Aqshort\*(Aq
\&     9     .melon.price[2]+1    \*(Aqshort\*(Aq
\&           .apple+9             \*(Aqstruct\*(Aq
\&    10     .apple+10            \*(Aqstruct\*(Aq
\&           .melon+10            \*(Aqstruct\*(Aq
\&    11     .apple+11            \*(Aqstruct\*(Aq
\&           .melon+11            \*(Aqstruct\*(Aq
.Ve
.Sp
The first member returned is always the \fIbest\fR member. The other
members are sorted according to the rules given above. This means
that members referenced without an offset are followed by members
referenced with an offset. Padding regions will be at the end.
.Sp
If \s-1OFFSET\s0 is not given in the method call, \f(CW\*(C`member\*(C'\fR will
return a list of \fIall\fR possible members of \s-1TYPE\s0.
.Sp
.Vb 1
\&  print "$_\en" for $c\->member(\*(Aqchoice\*(Aq);
.Ve
.Sp
This will print:
.Sp
.Vb 11
\&  .apple.color[0]
\&  .apple.color[1]
\&  .apple.size
\&  .apple.taste
\&  .grape[0]
\&  .grape[1]
\&  .grape[2]
\&  .melon.weight
\&  .melon.price[0]
\&  .melon.price[1]
\&  .melon.price[2]
.Ve
.Sp
In scalar context, the number of possible members is returned.
.RE
.SS "tag"
.IX Subsection "tag"
.ie n .IP """tag"" \s-1TYPE\s0" 8
.el .IP "\f(CWtag\fR \s-1TYPE\s0" 8
.IX Item "tag TYPE"
.PD 0
.ie n .IP """tag"" \s-1TYPE, TAG\s0" 8
.el .IP "\f(CWtag\fR \s-1TYPE, TAG\s0" 8
.IX Item "tag TYPE, TAG"
.ie n .IP """tag"" \s-1TYPE, TAG1\s0 => \s-1VALUE1, TAG2\s0 => \s-1VALUE2, ...\s0" 8
.el .IP "\f(CWtag\fR \s-1TYPE, TAG1\s0 => \s-1VALUE1, TAG2\s0 => \s-1VALUE2, ...\s0" 8
.IX Item "tag TYPE, TAG1 => VALUE1, TAG2 => VALUE2, ..."
.PD
The \f(CW\*(C`tag\*(C'\fR method can be used to tag properties to
a \s-1TYPE\s0. It's a bit like
having \f(CW\*(C`configure\*(C'\fR for individual types.
.Sp
See \*(L"\s-1USING TAGS\*(R"\s0 for an example.
.Sp
Note that while you can tag whole types as well as compound
members, it is not possible to tag array members, i.e. you
cannot treat, for example, \f(CW\*(C`a[1]\*(C'\fR and \f(CW\*(C`a[2]\*(C'\fR differently.
.Sp
Also note that in code like this
.Sp
.Vb 6
\&  struct test {
\&    int a;
\&    struct {
\&      int x;
\&    } b, c;
\&  };
.Ve
.Sp
if you tag \f(CW\*(C`test.b.x\*(C'\fR, this will also tag \f(CW\*(C`test.c.x\*(C'\fR implicitly.
.Sp
It is also possible to tag basic types if you really want
to do that, for example:
.Sp
.Vb 1
\&  $c\->tag(\*(Aqint\*(Aq, Format => \*(AqBinary\*(Aq);
.Ve
.Sp
To remove a tag from a type, you can either set that
tag to \f(CW\*(C`undef\*(C'\fR, for example
.Sp
.Vb 1
\&  $c\->tag(\*(Aqtest\*(Aq, Hooks => undef);
.Ve
.Sp
or use \f(CW\*(C`untag\*(C'\fR.
.Sp
To see if a tag is attached to a type or to get the value of
a tag, pass only the type and tag name to \f(CW\*(C`tag\*(C'\fR:
.Sp
.Vb 1
\&  $c\->tag(\*(Aqtest.a\*(Aq, Format => \*(AqBinary\*(Aq);
\&  
\&  $hooks = $c\->tag(\*(Aqtest.a\*(Aq, \*(AqHooks\*(Aq);
\&  $format = $c\->tag(\*(Aqtest.a\*(Aq, \*(AqFormat\*(Aq);
.Ve
.Sp
This will give you:
.Sp
.Vb 2
\&  $hooks = undef;
\&  $format = \*(AqBinary\*(Aq;
.Ve
.Sp
To see which tags are attached to a type, pass only the type.
The \f(CW\*(C`tag\*(C'\fR method will now return a hash reference
containing all tags attached to the type:
.Sp
.Vb 1
\&  $tags = $c\->tag(\*(Aqtest.a\*(Aq);
.Ve
.Sp
This will give you:
.Sp
.Vb 3
\&  $tags = {
\&    \*(AqFormat\*(Aq => \*(AqBinary\*(Aq
\&  };
.Ve
.Sp
\&\f(CW\*(C`tag\*(C'\fR will throw an exception if an error occurs.
If called as a 'set' method, it will return a reference to its
object, allowing you to chain together consecutive method calls.
.Sp
Note that when a compound is inlined, tags attached to the
inlined compound are ignored, for example:
.Sp
.Vb 6
\&  $c\->parse(<<ENDC);
\&  struct header {
\&    int id;
\&    int len;
\&    unsigned flags;
\&  };
\&  
\&  struct message {
\&    struct header;
\&    short samples[32];
\&  };
\&  ENDC
\&  
\&  for my $type (qw( header message header.len )) {
\&    $c\->tag($type, Hooks => { unpack => sub { print "unpack: $type\en"; @_ } });
\&  }
\&  
\&  for my $type (qw( header message )) {
\&    print "[unpacking $type]\en";
\&    $u = $c\->unpack($type, $data);
\&  }
.Ve
.Sp
This will print:
.Sp
.Vb 6
\&  [unpacking header]
\&  unpack: header.len
\&  unpack: header
\&  [unpacking message]
\&  unpack: header.len
\&  unpack: message
.Ve
.Sp
As you can see from the above output, tags attached to members
of inlined compounds (\f(CW\*(C`header.len\*(C'\fR are still handled.
.Sp
The following tags can be configured:
.RS 8
.ie n .IP """Format"" => 'Binary' | 'String'" 4
.el .IP "\f(CWFormat\fR => 'Binary' | 'String'" 4
.IX Item "Format => 'Binary' | 'String'"
The \f(CW\*(C`Format\*(C'\fR tag allows you to control the way binary data
is converted by \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR.
.Sp
If you tag a \f(CW\*(C`TYPE\*(C'\fR as \f(CW\*(C`Binary\*(C'\fR, it will not be converted
at all, i.e. it will be passed through as a binary string.
.Sp
If you tag it as \f(CW\*(C`String\*(C'\fR, it will be treated like
a null-terminated C string, i.e. \f(CW\*(C`unpack\*(C'\fR will
convert the C string to a Perl string and vice versa.
.Sp
See \*(L"The Format Tag\*(R" for an example.
.ie n .IP """ByteOrder"" => 'BigEndian' | 'LittleEndian'" 4
.el .IP "\f(CWByteOrder\fR => 'BigEndian' | 'LittleEndian'" 4
.IX Item "ByteOrder => 'BigEndian' | 'LittleEndian'"
The \f(CW\*(C`ByteOrder\*(C'\fR tag allows you to explicitly set the byte
order of a \s-1TYPE\s0.
.Sp
See \*(L"The ByteOrder Tag\*(R" for an example.
.ie n .IP """Dimension"" => '*'" 4
.el .IP "\f(CWDimension\fR => '*'" 4
.IX Item "Dimension => '*'"
.PD 0
.ie n .IP """Dimension"" => \s-1VALUE\s0" 4
.el .IP "\f(CWDimension\fR => \s-1VALUE\s0" 4
.IX Item "Dimension => VALUE"
.ie n .IP """Dimension"" => \s-1MEMBER\s0" 4
.el .IP "\f(CWDimension\fR => \s-1MEMBER\s0" 4
.IX Item "Dimension => MEMBER"
.ie n .IP """Dimension"" => \s-1SUB\s0" 4
.el .IP "\f(CWDimension\fR => \s-1SUB\s0" 4
.IX Item "Dimension => SUB"
.ie n .IP """Dimension"" => [ \s-1SUB, ARGS \s0]" 4
.el .IP "\f(CWDimension\fR => [ \s-1SUB, ARGS \s0]" 4
.IX Item "Dimension => [ SUB, ARGS ]"
.PD
The \f(CW\*(C`Dimension\*(C'\fR tag allows you to alter the size of an array
dynamically.
.Sp
You can tag fixed size arrays as being flexible using \f(CW\*(Aq*\*(Aq\fR.
This is useful if you cannot use flexible array members in
your source code.
.Sp
.Vb 1
\&  $c\->tag(\*(Aqtype.array\*(Aq, Dimension => \*(Aq*\*(Aq);
.Ve
.Sp
You can also tag an array to have a fixed size different
from the one it was originally declared with.
.Sp
.Vb 1
\&  $c\->tag(\*(Aqtype.array\*(Aq, Dimension => 42);
.Ve
.Sp
If the array is a member of a compound, you can also tag it
with to have a size corresponding to the value of another
member in that compound.
.Sp
.Vb 1
\&  $c\->tag(\*(Aqtype.array\*(Aq, Dimension => \*(Aqcount\*(Aq);
.Ve
.Sp
Finally, you can specify a subroutine that is called when
the size of the array needs to be determined.
.Sp
.Vb 1
\&  $c\->tag(\*(Aqtype.array\*(Aq, Dimension => \e&get_count);
.Ve
.Sp
By default, and if the array is a compound member, that
subroutine will be passed a reference to the hash storing
the data for the compound.
.Sp
You can also instruct Convert::Binary::C to pass additional
arguments to the subroutine by passing an array reference
instead of the subroutine reference. This array contains
the subroutine reference as well as a list of arguments.
It is possible to define certain special arguments using
the \f(CW\*(C`arg\*(C'\fR method.
.Sp
.Vb 1
\&  $c\->tag(\*(Aqtype.array\*(Aq, Dimension => [\e&get_count, $c\->arg(\*(AqSELF\*(Aq), 42]);
.Ve
.Sp
See \*(L"The Dimension Tag\*(R" for various examples.
.ie n .IP """Hooks"" => { \s-1HOOK\s0 => \s-1SUB, HOOK\s0 => [ \s-1SUB, ARGS \s0], ... }, ..." 4
.el .IP "\f(CWHooks\fR => { \s-1HOOK\s0 => \s-1SUB, HOOK\s0 => [ \s-1SUB, ARGS \s0], ... }, ..." 4
.IX Item "Hooks => { HOOK => SUB, HOOK => [ SUB, ARGS ], ... }, ..."
The \f(CW\*(C`Hooks\*(C'\fR tag allows you to register subroutines as hooks.
.Sp
Hooks are called whenever a certain \f(CW\*(C`TYPE\*(C'\fR is packed or
unpacked. Hooks are currently considered an \fBexperimental\fR
feature.
.Sp
\&\f(CW\*(C`HOOK\*(C'\fR can be one of the following:
.Sp
.Vb 4
\&  pack
\&  unpack
\&  pack_ptr
\&  unpack_ptr
.Ve
.Sp
\&\f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR hooks are called when processing
their \f(CW\*(C`TYPE\*(C'\fR, while \f(CW\*(C`pack_ptr\*(C'\fR and \f(CW\*(C`unpack_ptr\*(C'\fR hooks
are called when processing pointers to their \f(CW\*(C`TYPE\*(C'\fR.
.Sp
\&\f(CW\*(C`SUB\*(C'\fR is a reference to a subroutine that usually takes one
input argument, processes it and returns one output argument.
.Sp
Alternatively, you can pass a custom list of arguments to the
hook by using an array reference instead of \f(CW\*(C`SUB\*(C'\fR that holds
the subroutine reference in the first element and the arguments
to be passed to the subroutine as the other elements.
This way, you can even pass special arguments to the hook using
the \f(CW\*(C`arg\*(C'\fR method.
.Sp
Here are a few examples for registering hooks:
.Sp
.Vb 4
\&  $c\->tag(\*(AqObjectType\*(Aq, Hooks => {
\&            pack   => \e&obj_pack,
\&            unpack => \e&obj_unpack
\&          });
\&  
\&  $c\->tag(\*(AqProtocolId\*(Aq, Hooks => {
\&            unpack => sub { $protos[$_[0]] }
\&          });
\&  
\&  $c\->tag(\*(AqProtocolId\*(Aq, Hooks => {
\&            unpack_ptr => [sub {
\&                             sprintf "$_[0]:{0x%X}", $_[1]
\&                           },
\&                           $c\->arg(\*(AqTYPE\*(Aq, \*(AqDATA\*(Aq)
\&                          ],
\&          });
.Ve
.Sp
Note that the above example registers both an \f(CW\*(C`unpack\*(C'\fR hook
and an \f(CW\*(C`unpack_ptr\*(C'\fR hook for \f(CW\*(C`ProtocolId\*(C'\fR with two separate
calls to \f(CW\*(C`tag\*(C'\fR. As long as you don't explicitly
overwrite a previously registered hook, it won't be modified
or removed by registering other hooks for the same \f(CW\*(C`TYPE\*(C'\fR.
.Sp
To remove all registered hooks for a type, simply remove
the \f(CW\*(C`Hooks\*(C'\fR tag:
.Sp
.Vb 1
\&  $c\->untag(\*(AqProtocolId\*(Aq, \*(AqHooks\*(Aq);
.Ve
.Sp
To remove only a single hook, pass \f(CW\*(C`undef\*(C'\fR as \f(CW\*(C`SUB\*(C'\fR instead
of a subroutine reference:
.Sp
.Vb 1
\&  $c\->tag(\*(AqObjectType\*(Aq, Hooks => { pack => undef });
.Ve
.Sp
If all hooks are removed, the whole \f(CW\*(C`Hooks\*(C'\fR tag is removed.
.Sp
See \*(L"The Hooks Tag\*(R" for examples on how to use hooks.
.RE
.RS 8
.RE
.SS "untag"
.IX Subsection "untag"
.ie n .IP """untag"" \s-1TYPE\s0" 8
.el .IP "\f(CWuntag\fR \s-1TYPE\s0" 8
.IX Item "untag TYPE"
.PD 0
.ie n .IP """untag"" \s-1TYPE, TAG1, TAG2, ...\s0" 8
.el .IP "\f(CWuntag\fR \s-1TYPE, TAG1, TAG2, ...\s0" 8
.IX Item "untag TYPE, TAG1, TAG2, ..."
.PD
Use the \f(CW\*(C`untag\*(C'\fR method to remove one, more, or all
tags from a type. If you don't pass any tag names, all tags
attached to the type will be removed. Otherwise only the listed
tags will be removed.
.Sp
See \*(L"\s-1USING TAGS\*(R"\s0 for an example.
.SS "arg"
.IX Subsection "arg"
.ie n .IP """arg"" '\s-1ARG\s0', ..." 8
.el .IP "\f(CWarg\fR '\s-1ARG\s0', ..." 8
.IX Item "arg 'ARG', ..."
Creates placeholders for special arguments to be passed to hooks
or other subroutines. These arguments are currently:
.RS 8
.ie n .IP """SELF""" 4
.el .IP "\f(CWSELF\fR" 4
.IX Item "SELF"
A reference to the calling Convert::Binary::C object. This may be
useful if you need to work with the object inside the subroutine.
.ie n .IP """TYPE""" 4
.el .IP "\f(CWTYPE\fR" 4
.IX Item "TYPE"
The name of the type that is currently being processed by the hook.
.ie n .IP """DATA""" 4
.el .IP "\f(CWDATA\fR" 4
.IX Item "DATA"
The data argument that is passed to the subroutine.
.ie n .IP """HOOK""" 4
.el .IP "\f(CWHOOK\fR" 4
.IX Item "HOOK"
The type of the hook as which the subroutine has been called,
for example \f(CW\*(C`pack\*(C'\fR or \f(CW\*(C`unpack_ptr\*(C'\fR.
.RE
.RS 8
.Sp
\&\f(CW\*(C`arg\*(C'\fR will return a placeholder for each argument it is
being passed. Note that not all arguments may be supported depending
on the context of the subroutine.
.RE
.SS "dependencies"
.IX Subsection "dependencies"
.ie n .IP """dependencies""" 8
.el .IP "\f(CWdependencies\fR" 8
.IX Item "dependencies"
After some code has been parsed using either
the \f(CW\*(C`parse\*(C'\fR or \f(CW\*(C`parse_file\*(C'\fR methods,
the \f(CW\*(C`dependencies\*(C'\fR method can be used to
retrieve information about all files that the object
depends on, i.e. all files that have been parsed.
.Sp
In scalar context, the method returns a hash reference.
Each key is the name of a file. The values are again hash
references, each of which holds the size, modification
time (mtime), and change time (ctime) of the file at the
moment it was parsed.
.Sp
.Vb 2
\&  use Convert::Binary::C;
\&  use Data::Dumper;
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # Create object, set include path, parse \*(Aqstring.h\*(Aq header
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  my $c = Convert::Binary::C\->new
\&          \->Include(\*(Aq/usr/lib/gcc/i686\-pc\-linux\-gnu/4.5.2/include\*(Aq,
\&                    \*(Aq/usr/lib/gcc/i686\-pc\-linux\-gnu/4.5.2/include\-fixed\*(Aq,
\&                    \*(Aq/usr/include\*(Aq)
\&          \->parse_file(\*(Aqstring.h\*(Aq);
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # Get dependencies of the object, extract dependency files
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  my $depend = $c\->dependencies;
\&  my @files  = keys %$depend;
\&  
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  # Dump dependencies and files
\&  #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  print Data::Dumper\->Dump([$depend, \e@files],
\&                        [qw( depend   *files )]);
.Ve
.Sp
The above code would print something like this:
.Sp
.Vb 10
\&  $depend = {
\&    \*(Aq/usr/include/features.h\*(Aq => {
\&      \*(Aqctime\*(Aq => 1300268052,
\&      \*(Aqmtime\*(Aq => 1300267911,
\&      \*(Aqsize\*(Aq => 12511
\&    },
\&    \*(Aq/usr/include/gnu/stubs\-32.h\*(Aq => {
\&      \*(Aqctime\*(Aq => 1300268051,
\&      \*(Aqmtime\*(Aq => 1300268010,
\&      \*(Aqsize\*(Aq => 624
\&    },
\&    \*(Aq/usr/include/sys/cdefs.h\*(Aq => {
\&      \*(Aqctime\*(Aq => 1300268051,
\&      \*(Aqmtime\*(Aq => 1300267957,
\&      \*(Aqsize\*(Aq => 13195
\&    },
\&    \*(Aq/usr/include/gnu/stubs.h\*(Aq => {
\&      \*(Aqctime\*(Aq => 1300268051,
\&      \*(Aqmtime\*(Aq => 1300267911,
\&      \*(Aqsize\*(Aq => 315
\&    },
\&    \*(Aq/usr/include/string.h\*(Aq => {
\&      \*(Aqctime\*(Aq => 1300268052,
\&      \*(Aqmtime\*(Aq => 1300267944,
\&      \*(Aqsize\*(Aq => 22572
\&    },
\&    \*(Aq/usr/lib/gcc/i686\-pc\-linux\-gnu/4.5.2/include/stddef.h\*(Aq => {
\&      \*(Aqctime\*(Aq => 1300365679,
\&      \*(Aqmtime\*(Aq => 1300363914,
\&      \*(Aqsize\*(Aq => 12542
\&    },
\&    \*(Aq/usr/include/bits/wordsize.h\*(Aq => {
\&      \*(Aqctime\*(Aq => 1300268051,
\&      \*(Aqmtime\*(Aq => 1300267937,
\&      \*(Aqsize\*(Aq => 873
\&    },
\&    \*(Aq/usr/include/xlocale.h\*(Aq => {
\&      \*(Aqctime\*(Aq => 1300268051,
\&      \*(Aqmtime\*(Aq => 1300267915,
\&      \*(Aqsize\*(Aq => 1764
\&    }
\&  };
\&  @files = (
\&    \*(Aq/usr/include/features.h\*(Aq,
\&    \*(Aq/usr/include/gnu/stubs\-32.h\*(Aq,
\&    \*(Aq/usr/include/sys/cdefs.h\*(Aq,
\&    \*(Aq/usr/include/gnu/stubs.h\*(Aq,
\&    \*(Aq/usr/include/string.h\*(Aq,
\&    \*(Aq/usr/lib/gcc/i686\-pc\-linux\-gnu/4.5.2/include/stddef.h\*(Aq,
\&    \*(Aq/usr/include/bits/wordsize.h\*(Aq,
\&    \*(Aq/usr/include/xlocale.h\*(Aq
\&  );
.Ve
.Sp
In list context, the method returns the names of all
files that have been parsed, i.e. the following lines
are equivalent:
.Sp
.Vb 2
\&  @files = keys %{$c\->dependencies};
\&  @files = $c\->dependencies;
.Ve
.SS "sourcify"
.IX Subsection "sourcify"
.ie n .IP """sourcify""" 8
.el .IP "\f(CWsourcify\fR" 8
.IX Item "sourcify"
.PD 0
.ie n .IP """sourcify"" \s-1CONFIG\s0" 8
.el .IP "\f(CWsourcify\fR \s-1CONFIG\s0" 8
.IX Item "sourcify CONFIG"
.PD
Returns a string that holds the C source code necessary to
represent all parsed C data structures.
.Sp
.Vb 1
\&  use Convert::Binary::C;
\&  
\&  $c = new Convert::Binary::C;
\&  $c\->parse(<<\*(AqEND\*(Aq);
\&  
\&  #define ADD(a, b) ((a) + (b))
\&  #define NUMBER 42
\&  
\&  typedef struct _mytype mytype;
\&  
\&  struct _mytype {
\&    union {
\&      int         iCount;
\&      enum count *pCount;
\&    } counter;
\&  #pragma pack( push, 1 )
\&    struct {
\&      char string[NUMBER];
\&      int  array[NUMBER/sizeof(int)];
\&    } storage;
\&  #pragma pack( pop )
\&    mytype *next;
\&  };
\&  
\&  enum count { ZERO, ONE, TWO, THREE };
\&  
\&  END
\&  
\&  print $c\->sourcify;
.Ve
.Sp
The above code would print something like this:
.Sp
.Vb 1
\&  /* typedef predeclarations */
\&  
\&  typedef struct _mytype mytype;
\&  
\&  /* defined enums */
\&  
\&  enum count
\&  {
\&        ZERO,
\&        ONE,
\&        TWO,
\&        THREE
\&  };
\&  
\&  
\&  /* defined structs and unions */
\&  
\&  struct _mytype
\&  {
\&        union
\&        {
\&                int iCount;
\&                enum count *pCount;
\&        } counter;
\&  #pragma pack(push, 1)
\&        struct
\&        {
\&                char string[42];
\&                int array[10];
\&        } storage;
\&  #pragma pack(pop)
\&        mytype *next;
\&  };
.Ve
.Sp
The purpose of the \f(CW\*(C`sourcify\*(C'\fR method is to enable
some kind of platform-independent caching. The C code generated
by \f(CW\*(C`sourcify\*(C'\fR can be parsed by any standard C compiler,
as well as of course by the Convert::Binary::C parser. However, the code
may be significantly shorter than the code that has originally been parsed.
.Sp
When parsing a typical header file, it's easily possible that you need
to open dozens of other files that are included from that file, and
end up parsing several hundred kilobytes of C code. Since most of it
is usually preprocessor directives, function prototypes and comments,
the \f(CW\*(C`sourcify\*(C'\fR function strips this down to a few
kilobytes. Saving the \f(CW\*(C`sourcify\*(C'\fR string and parsing
it next time instead of the original code may be a lot faster.
.Sp
The \f(CW\*(C`sourcify\*(C'\fR method takes a hash reference as an
optional argument. It can be used to tweak the method's output.
The following options can be configured.
.RS 8
.ie n .IP """Context"" => 0 | 1" 4
.el .IP "\f(CWContext\fR => 0 | 1" 4
.IX Item "Context => 0 | 1"
Turns preprocessor context information on or off. If this is turned
on, \f(CW\*(C`sourcify\*(C'\fR will insert \f(CW\*(C`#line\*(C'\fR preprocessor
directives in its output. So in the above example
.Sp
.Vb 1
\&  print $c\->sourcify({ Context => 1 });
.Ve
.Sp
would print:
.Sp
.Vb 1
\&  /* typedef predeclarations */
\&  
\&  typedef struct _mytype mytype;
\&  
\&  /* defined enums */
\&  
\&  
\&  #line 21 "[buffer]"
\&  enum count
\&  {
\&        ZERO,
\&        ONE,
\&        TWO,
\&        THREE
\&  };
\&  
\&  
\&  /* defined structs and unions */
\&  
\&  
\&  #line 7 "[buffer]"
\&  struct _mytype
\&  {
\&  #line 8 "[buffer]"
\&        union
\&        {
\&                int iCount;
\&                enum count *pCount;
\&        } counter;
\&  #pragma pack(push, 1)
\&  #line 13 "[buffer]"
\&        struct
\&        {
\&                char string[42];
\&                int array[10];
\&        } storage;
\&  #pragma pack(pop)
\&        mytype *next;
\&  };
.Ve
.Sp
Note that \f(CW"[buffer]"\fR refers to the here-doc buffer when
using \f(CW\*(C`parse\*(C'\fR.
.ie n .IP """Defines"" => 0 | 1" 4
.el .IP "\f(CWDefines\fR => 0 | 1" 4
.IX Item "Defines => 0 | 1"
Turn this on if you want all the defined macros to be part of
the source code output. Given the example code above
.Sp
.Vb 1
\&  print $c\->sourcify({ Defines => 1 });
.Ve
.Sp
would print:
.Sp
.Vb 1
\&  /* typedef predeclarations */
\&  
\&  typedef struct _mytype mytype;
\&  
\&  /* defined enums */
\&  
\&  enum count
\&  {
\&        ZERO,
\&        ONE,
\&        TWO,
\&        THREE
\&  };
\&  
\&  
\&  /* defined structs and unions */
\&  
\&  struct _mytype
\&  {
\&        union
\&        {
\&                int iCount;
\&                enum count *pCount;
\&        } counter;
\&  #pragma pack(push, 1)
\&        struct
\&        {
\&                char string[42];
\&                int array[10];
\&        } storage;
\&  #pragma pack(pop)
\&        mytype *next;
\&  };
\&  
\&  /* preprocessor defines */
\&  
\&  #define ADD(a, b) ((a) + (b))
\&  #define NUMBER 42
.Ve
.Sp
The macro definitions always appear at the end of the source code.
The order of the macro definitions is undefined.
.RE
.RS 8
.RE
.PP
The following methods can be used to retrieve information about the
definitions that have been parsed. The examples given in the description
for \f(CW\*(C`enum\*(C'\fR, \f(CW\*(C`compound\*(C'\fR and \f(CW\*(C`typedef\*(C'\fR all
assume this piece of C code has been parsed:
.PP
.Vb 2
\&  #define ABC_SIZE 2
\&  #define MULTIPLY(x, y) ((x)*(y))
\&  
\&  #ifdef ABC_SIZE
\&  # define DEFINED
\&  #else
\&  # define NOT_DEFINED
\&  #endif
\&  
\&  typedef unsigned long U32;
\&  typedef void *any;
\&  
\&  enum _\|_socket_type
\&  {
\&    SOCK_STREAM    = 1,
\&    SOCK_DGRAM     = 2,
\&    SOCK_RAW       = 3,
\&    SOCK_RDM       = 4,
\&    SOCK_SEQPACKET = 5,
\&    SOCK_PACKET    = 10
\&  };
\&  
\&  struct STRUCT_SV {
\&    void *sv_any;
\&    U32   sv_refcnt;
\&    U32   sv_flags;
\&  };
\&  
\&  typedef union {
\&    int abc[ABC_SIZE];
\&    struct xxx {
\&      int a;
\&      int b;
\&    }   ab[3][4];
\&    any ptr;
\&  } test;
.Ve
.SS "enum_names"
.IX Subsection "enum_names"
.ie n .IP """enum_names""" 8
.el .IP "\f(CWenum_names\fR" 8
.IX Item "enum_names"
Returns a list of identifiers of all defined enumeration
objects. Enumeration objects don't necessarily have an
identifier, so something like
.Sp
.Vb 1
\&  enum { A, B, C };
.Ve
.Sp
will obviously not appear in the list returned by
the \f(CW\*(C`enum_names\*(C'\fR method. Also, enumerations
that are not defined within the source code \- like in
.Sp
.Vb 4
\&  struct foo {
\&    enum weekday *pWeekday;
\&    unsigned long year;
\&  };
.Ve
.Sp
where only a pointer to the \f(CW\*(C`weekday\*(C'\fR enumeration object is used \- will
not be returned, even though they have an identifier. So for the above two
enumerations, \f(CW\*(C`enum_names\*(C'\fR will return an empty list:
.Sp
.Vb 1
\&  @names = $c\->enum_names;
.Ve
.Sp
The only way to retrieve a list of all enumeration identifiers
is to use the \f(CW\*(C`enum\*(C'\fR method without additional
arguments. You can get a list of all enumeration objects
that have an identifier by using
.Sp
.Vb 1
\&  @enums = map { $_\->{identifier} || () } $c\->enum;
.Ve
.Sp
but these may not have a definition. Thus, the two arrays would
look like this:
.Sp
.Vb 2
\&  @names = ();
\&  @enums = (\*(Aqweekday\*(Aq);
.Ve
.Sp
The \f(CW\*(C`def\*(C'\fR method returns a true value for all identifiers returned
by \f(CW\*(C`enum_names\*(C'\fR.
.SS "enum"
.IX Subsection "enum"
.IP "enum" 8
.IX Item "enum"
.PD 0
.ie n .IP """enum"" \s-1LIST\s0" 8
.el .IP "\f(CWenum\fR \s-1LIST\s0" 8
.IX Item "enum LIST"
.PD
Returns a list of references to hashes containing
detailed information about all enumerations that
have been parsed.
.Sp
If a list of enumeration identifiers is passed to the
method, the returned list will only contain hash
references for those enumerations. The enumeration
identifiers may optionally be prefixed by \f(CW\*(C`enum\*(C'\fR.
.Sp
If an enumeration identifier cannot be found, the returned
list will contain an undefined value at that position.
.Sp
In scalar context, the number of enumerations will
be returned as long as the number of arguments to
the method call is not 1. In the latter case, a
hash reference holding information for the enumeration
will be returned.
.Sp
The list returned by the \f(CW\*(C`enum\*(C'\fR method looks
similar to this:
.Sp
.Vb 10
\&  @enum = (
\&    {
\&      \*(Aqenumerators\*(Aq => {
\&        \*(AqSOCK_STREAM\*(Aq => 1,
\&        \*(AqSOCK_RAW\*(Aq => 3,
\&        \*(AqSOCK_SEQPACKET\*(Aq => 5,
\&        \*(AqSOCK_RDM\*(Aq => 4,
\&        \*(AqSOCK_PACKET\*(Aq => 10,
\&        \*(AqSOCK_DGRAM\*(Aq => 2
\&      },
\&      \*(Aqidentifier\*(Aq => \*(Aq_\|_socket_type\*(Aq,
\&      \*(Aqcontext\*(Aq => \*(Aqdefinitions.c(13)\*(Aq,
\&      \*(Aqsize\*(Aq => 4,
\&      \*(Aqsign\*(Aq => 0
\&    }
\&  );
.Ve
.RS 8
.ie n .IP """identifier""" 4
.el .IP "\f(CWidentifier\fR" 4
.IX Item "identifier"
holds the enumeration identifier. This key is not
present if the enumeration has no identifier.
.ie n .IP """context""" 4
.el .IP "\f(CWcontext\fR" 4
.IX Item "context"
is the context in which the enumeration is defined. This
is the filename followed by the line number in parentheses.
.ie n .IP """enumerators""" 4
.el .IP "\f(CWenumerators\fR" 4
.IX Item "enumerators"
is a reference to a hash table that holds
all enumerators of the enumeration.
.ie n .IP """sign""" 4
.el .IP "\f(CWsign\fR" 4
.IX Item "sign"
is a boolean indicating if the enumeration is
signed (i.e. has negative values).
.RE
.RS 8
.Sp
One useful application may be to create a hash table that
holds all enumerators of all defined enumerations:
.Sp
.Vb 1
\&  %enum = map %{ $_\->{enumerators} || {} }, $c\->enum;
.Ve
.Sp
The \f(CW%enum\fR hash table would then be:
.Sp
.Vb 8
\&  %enum = (
\&    \*(AqSOCK_STREAM\*(Aq => 1,
\&    \*(AqSOCK_RAW\*(Aq => 3,
\&    \*(AqSOCK_SEQPACKET\*(Aq => 5,
\&    \*(AqSOCK_RDM\*(Aq => 4,
\&    \*(AqSOCK_DGRAM\*(Aq => 2,
\&    \*(AqSOCK_PACKET\*(Aq => 10
\&  );
.Ve
.RE
.SS "compound_names"
.IX Subsection "compound_names"
.ie n .IP """compound_names""" 8
.el .IP "\f(CWcompound_names\fR" 8
.IX Item "compound_names"
Returns a list of identifiers of all structs and unions
(compound data structures) that are defined in the parsed
source code. Like enumerations, compounds don't need to
have an identifier, nor do they need to be defined.
.Sp
Again, the only way to retrieve information about all
struct and union objects is to use the \f(CW\*(C`compound\*(C'\fR method
and don't pass it any arguments. If you should need a
list of all struct and union identifiers, you can use:
.Sp
.Vb 1
\&  @compound = map { $_\->{identifier} || () } $c\->compound;
.Ve
.Sp
The \f(CW\*(C`def\*(C'\fR method returns a true value for all identifiers returned
by \f(CW\*(C`compound_names\*(C'\fR.
.Sp
If you need the names of only the structs or only the unions, use
the \f(CW\*(C`struct_names\*(C'\fR and \f(CW\*(C`union_names\*(C'\fR methods
respectively.
.SS "compound"
.IX Subsection "compound"
.ie n .IP """compound""" 8
.el .IP "\f(CWcompound\fR" 8
.IX Item "compound"
.PD 0
.ie n .IP """compound"" \s-1LIST\s0" 8
.el .IP "\f(CWcompound\fR \s-1LIST\s0" 8
.IX Item "compound LIST"
.PD
Returns a list of references to hashes containing
detailed information about all compounds (structs and
unions) that have been parsed.
.Sp
If a list of struct/union identifiers is passed to the
method, the returned list will only contain hash
references for those compounds. The identifiers may
optionally be prefixed by \f(CW\*(C`struct\*(C'\fR or \f(CW\*(C`union\*(C'\fR,
which limits the search to the specified kind of
compound.
.Sp
If an identifier cannot be found, the returned list
will contain an undefined value at that position.
.Sp
In scalar context, the number of compounds will
be returned as long as the number of arguments to
the method call is not 1. In the latter case, a
hash reference holding information for the compound
will be returned.
.Sp
The list returned by the \f(CW\*(C`compound\*(C'\fR method looks similar
to this:
.Sp
.Vb 10
\&  @compound = (
\&    {
\&      \*(Aqidentifier\*(Aq => \*(AqSTRUCT_SV\*(Aq,
\&      \*(Aqalign\*(Aq => 1,
\&      \*(Aqcontext\*(Aq => \*(Aqdefinitions.c(23)\*(Aq,
\&      \*(Aqpack\*(Aq => 0,
\&      \*(Aqtype\*(Aq => \*(Aqstruct\*(Aq,
\&      \*(Aqdeclarations\*(Aq => [
\&        {
\&          \*(Aqdeclarators\*(Aq => [
\&            {
\&              \*(Aqdeclarator\*(Aq => \*(Aq*sv_any\*(Aq,
\&              \*(Aqsize\*(Aq => 4,
\&              \*(Aqoffset\*(Aq => 0
\&            }
\&          ],
\&          \*(Aqtype\*(Aq => \*(Aqvoid\*(Aq
\&        },
\&        {
\&          \*(Aqdeclarators\*(Aq => [
\&            {
\&              \*(Aqdeclarator\*(Aq => \*(Aqsv_refcnt\*(Aq,
\&              \*(Aqsize\*(Aq => 4,
\&              \*(Aqoffset\*(Aq => 4
\&            }
\&          ],
\&          \*(Aqtype\*(Aq => \*(AqU32\*(Aq
\&        },
\&        {
\&          \*(Aqdeclarators\*(Aq => [
\&            {
\&              \*(Aqdeclarator\*(Aq => \*(Aqsv_flags\*(Aq,
\&              \*(Aqsize\*(Aq => 4,
\&              \*(Aqoffset\*(Aq => 8
\&            }
\&          ],
\&          \*(Aqtype\*(Aq => \*(AqU32\*(Aq
\&        }
\&      ],
\&      \*(Aqsize\*(Aq => 12
\&    },
\&    {
\&      \*(Aqidentifier\*(Aq => \*(Aqxxx\*(Aq,
\&      \*(Aqalign\*(Aq => 1,
\&      \*(Aqcontext\*(Aq => \*(Aqdefinitions.c(31)\*(Aq,
\&      \*(Aqpack\*(Aq => 0,
\&      \*(Aqtype\*(Aq => \*(Aqstruct\*(Aq,
\&      \*(Aqdeclarations\*(Aq => [
\&        {
\&          \*(Aqdeclarators\*(Aq => [
\&            {
\&              \*(Aqdeclarator\*(Aq => \*(Aqa\*(Aq,
\&              \*(Aqsize\*(Aq => 4,
\&              \*(Aqoffset\*(Aq => 0
\&            }
\&          ],
\&          \*(Aqtype\*(Aq => \*(Aqint\*(Aq
\&        },
\&        {
\&          \*(Aqdeclarators\*(Aq => [
\&            {
\&              \*(Aqdeclarator\*(Aq => \*(Aqb\*(Aq,
\&              \*(Aqsize\*(Aq => 4,
\&              \*(Aqoffset\*(Aq => 4
\&            }
\&          ],
\&          \*(Aqtype\*(Aq => \*(Aqint\*(Aq
\&        }
\&      ],
\&      \*(Aqsize\*(Aq => 8
\&    },
\&    {
\&      \*(Aqalign\*(Aq => 1,
\&      \*(Aqcontext\*(Aq => \*(Aqdefinitions.c(29)\*(Aq,
\&      \*(Aqpack\*(Aq => 0,
\&      \*(Aqtype\*(Aq => \*(Aqunion\*(Aq,
\&      \*(Aqdeclarations\*(Aq => [
\&        {
\&          \*(Aqdeclarators\*(Aq => [
\&            {
\&              \*(Aqdeclarator\*(Aq => \*(Aqabc[2]\*(Aq,
\&              \*(Aqsize\*(Aq => 8,
\&              \*(Aqoffset\*(Aq => 0
\&            }
\&          ],
\&          \*(Aqtype\*(Aq => \*(Aqint\*(Aq
\&        },
\&        {
\&          \*(Aqdeclarators\*(Aq => [
\&            {
\&              \*(Aqdeclarator\*(Aq => \*(Aqab[3][4]\*(Aq,
\&              \*(Aqsize\*(Aq => 96,
\&              \*(Aqoffset\*(Aq => 0
\&            }
\&          ],
\&          \*(Aqtype\*(Aq => \*(Aqstruct xxx\*(Aq
\&        },
\&        {
\&          \*(Aqdeclarators\*(Aq => [
\&            {
\&              \*(Aqdeclarator\*(Aq => \*(Aqptr\*(Aq,
\&              \*(Aqsize\*(Aq => 4,
\&              \*(Aqoffset\*(Aq => 0
\&            }
\&          ],
\&          \*(Aqtype\*(Aq => \*(Aqany\*(Aq
\&        }
\&      ],
\&      \*(Aqsize\*(Aq => 96
\&    }
\&  );
.Ve
.RS 8
.ie n .IP """identifier""" 4
.el .IP "\f(CWidentifier\fR" 4
.IX Item "identifier"
holds the struct or union identifier. This
key is not present if the compound has no identifier.
.ie n .IP """context""" 4
.el .IP "\f(CWcontext\fR" 4
.IX Item "context"
is the context in which the struct or union is defined. This
is the filename followed by the line number in parentheses.
.ie n .IP """type""" 4
.el .IP "\f(CWtype\fR" 4
.IX Item "type"
is either 'struct' or 'union'.
.ie n .IP """size""" 4
.el .IP "\f(CWsize\fR" 4
.IX Item "size"
is the size of the struct or union.
.ie n .IP """align""" 4
.el .IP "\f(CWalign\fR" 4
.IX Item "align"
is the alignment of the struct or union.
.ie n .IP """pack""" 4
.el .IP "\f(CWpack\fR" 4
.IX Item "pack"
is the struct member alignment if the compound
is packed, or zero otherwise.
.ie n .IP """declarations""" 4
.el .IP "\f(CWdeclarations\fR" 4
.IX Item "declarations"
is an array of hash references describing each struct
declaration:
.RS 4
.ie n .IP """type""" 4
.el .IP "\f(CWtype\fR" 4
.IX Item "type"
is the type of the struct declaration. This may be a
string or a reference to a hash describing the type.
.ie n .IP """declarators""" 4
.el .IP "\f(CWdeclarators\fR" 4
.IX Item "declarators"
is an array of hashes describing each declarator:
.RS 4
.ie n .IP """declarator""" 4
.el .IP "\f(CWdeclarator\fR" 4
.IX Item "declarator"
is a string representation of the declarator.
.ie n .IP """offset""" 4
.el .IP "\f(CWoffset\fR" 4
.IX Item "offset"
is the offset of the struct member represented by
the current declarator relative to the beginning
of the struct or union.
.ie n .IP """size""" 4
.el .IP "\f(CWsize\fR" 4
.IX Item "size"
is the size occupied by the struct member represented
by the current declarator.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.RE
.RS 8
.Sp
It may be useful to have separate lists for structs and
unions. One way to retrieve such lists would be to use
.Sp
.Vb 2
\&  push @{$_\->{type} eq \*(Aqunion\*(Aq ? \e@unions : \e@structs}, $_
\&      for $c\->compound;
.Ve
.Sp
However, you should use the \f(CW\*(C`struct\*(C'\fR and \f(CW\*(C`union\*(C'\fR methods,
which is a lot simpler:
.Sp
.Vb 2
\&  @structs = $c\->struct;
\&  @unions  = $c\->union;
.Ve
.RE
.SS "struct_names"
.IX Subsection "struct_names"
.ie n .IP """struct_names""" 8
.el .IP "\f(CWstruct_names\fR" 8
.IX Item "struct_names"
Returns a list of all defined struct identifiers.
This is equivalent to calling \f(CW\*(C`compound_names\*(C'\fR, just
that it only returns the names of the struct identifiers and
doesn't return the names of the union identifiers.
.SS "struct"
.IX Subsection "struct"
.ie n .IP """struct""" 8
.el .IP "\f(CWstruct\fR" 8
.IX Item "struct"
.PD 0
.ie n .IP """struct"" \s-1LIST\s0" 8
.el .IP "\f(CWstruct\fR \s-1LIST\s0" 8
.IX Item "struct LIST"
.PD
Like the \f(CW\*(C`compound\*(C'\fR method, but only allows for structs.
.SS "union_names"
.IX Subsection "union_names"
.ie n .IP """union_names""" 8
.el .IP "\f(CWunion_names\fR" 8
.IX Item "union_names"
Returns a list of all defined union identifiers.
This is equivalent to calling \f(CW\*(C`compound_names\*(C'\fR, just
that it only returns the names of the union identifiers and
doesn't return the names of the struct identifiers.
.SS "union"
.IX Subsection "union"
.ie n .IP """union""" 8
.el .IP "\f(CWunion\fR" 8
.IX Item "union"
.PD 0
.ie n .IP """union"" \s-1LIST\s0" 8
.el .IP "\f(CWunion\fR \s-1LIST\s0" 8
.IX Item "union LIST"
.PD
Like the \f(CW\*(C`compound\*(C'\fR method, but only allows for unions.
.SS "typedef_names"
.IX Subsection "typedef_names"
.ie n .IP """typedef_names""" 8
.el .IP "\f(CWtypedef_names\fR" 8
.IX Item "typedef_names"
Returns a list of all defined typedef identifiers. Typedefs
that do not specify a type that you could actually work with
will not be returned.
.Sp
The \f(CW\*(C`def\*(C'\fR method returns a true value for all identifiers returned
by \f(CW\*(C`typedef_names\*(C'\fR.
.SS "typedef"
.IX Subsection "typedef"
.ie n .IP """typedef""" 8
.el .IP "\f(CWtypedef\fR" 8
.IX Item "typedef"
.PD 0
.ie n .IP """typedef"" \s-1LIST\s0" 8
.el .IP "\f(CWtypedef\fR \s-1LIST\s0" 8
.IX Item "typedef LIST"
.PD
Returns a list of references to hashes containing
detailed information about all typedefs that have
been parsed.
.Sp
If a list of typedef identifiers is passed to the
method, the returned list will only contain hash
references for those typedefs.
.Sp
If an identifier cannot be found, the returned list
will contain an undefined value at that position.
.Sp
In scalar context, the number of typedefs will
be returned as long as the number of arguments to
the method call is not 1. In the latter case, a
hash reference holding information for the typedef
will be returned.
.Sp
The list returned by the \f(CW\*(C`typedef\*(C'\fR method looks similar
to this:
.Sp
.Vb 10
\&  @typedef = (
\&    {
\&      \*(Aqdeclarator\*(Aq => \*(AqU32\*(Aq,
\&      \*(Aqtype\*(Aq => \*(Aqunsigned long\*(Aq
\&    },
\&    {
\&      \*(Aqdeclarator\*(Aq => \*(Aq*any\*(Aq,
\&      \*(Aqtype\*(Aq => \*(Aqvoid\*(Aq
\&    },
\&    {
\&      \*(Aqdeclarator\*(Aq => \*(Aqtest\*(Aq,
\&      \*(Aqtype\*(Aq => {
\&        \*(Aqalign\*(Aq => 1,
\&        \*(Aqcontext\*(Aq => \*(Aqdefinitions.c(29)\*(Aq,
\&        \*(Aqpack\*(Aq => 0,
\&        \*(Aqtype\*(Aq => \*(Aqunion\*(Aq,
\&        \*(Aqdeclarations\*(Aq => [
\&          {
\&            \*(Aqdeclarators\*(Aq => [
\&              {
\&                \*(Aqdeclarator\*(Aq => \*(Aqabc[2]\*(Aq,
\&                \*(Aqsize\*(Aq => 8,
\&                \*(Aqoffset\*(Aq => 0
\&              }
\&            ],
\&            \*(Aqtype\*(Aq => \*(Aqint\*(Aq
\&          },
\&          {
\&            \*(Aqdeclarators\*(Aq => [
\&              {
\&                \*(Aqdeclarator\*(Aq => \*(Aqab[3][4]\*(Aq,
\&                \*(Aqsize\*(Aq => 96,
\&                \*(Aqoffset\*(Aq => 0
\&              }
\&            ],
\&            \*(Aqtype\*(Aq => \*(Aqstruct xxx\*(Aq
\&          },
\&          {
\&            \*(Aqdeclarators\*(Aq => [
\&              {
\&                \*(Aqdeclarator\*(Aq => \*(Aqptr\*(Aq,
\&                \*(Aqsize\*(Aq => 4,
\&                \*(Aqoffset\*(Aq => 0
\&              }
\&            ],
\&            \*(Aqtype\*(Aq => \*(Aqany\*(Aq
\&          }
\&        ],
\&        \*(Aqsize\*(Aq => 96
\&      }
\&    }
\&  );
.Ve
.RS 8
.ie n .IP """declarator""" 4
.el .IP "\f(CWdeclarator\fR" 4
.IX Item "declarator"
is the type declarator.
.ie n .IP """type""" 4
.el .IP "\f(CWtype\fR" 4
.IX Item "type"
is the type specification. This may be a string
or a reference to a hash describing the type.
See \f(CW\*(C`enum\*(C'\fR and \f(CW\*(C`compound\*(C'\fR for
a description on how to interpret this hash.
.RE
.RS 8
.RE
.SS "macro_names"
.IX Subsection "macro_names"
.ie n .IP """macro_names""" 8
.el .IP "\f(CWmacro_names\fR" 8
.IX Item "macro_names"
Returns a list of all defined macro names.
.Sp
The list returned by the \f(CW\*(C`macro_names\*(C'\fR method
looks similar to this:
.Sp
.Vb 7
\&  @macro_names = (
\&    \*(Aq_\|_STDC_VERSION_\|_\*(Aq,
\&    \*(Aq_\|_STDC_HOSTED_\|_\*(Aq,
\&    \*(AqDEFINED\*(Aq,
\&    \*(AqMULTIPLY\*(Aq,
\&    \*(AqABC_SIZE\*(Aq
\&  );
.Ve
.Sp
This works only as long as the preprocessor is not reset.
See \*(L"Preprocessor configuration\*(R" for details.
.SS "macro"
.IX Subsection "macro"
.ie n .IP """macro""" 8
.el .IP "\f(CWmacro\fR" 8
.IX Item "macro"
.PD 0
.ie n .IP """macro"" \s-1LIST\s0" 8
.el .IP "\f(CWmacro\fR \s-1LIST\s0" 8
.IX Item "macro LIST"
.PD
Returns the definitions for all defined macros.
.Sp
If a list of macro names is passed to the method, the
returned list will only contain the definitions for those
macros. For undefined macros, \f(CW\*(C`undef\*(C'\fR will be returned.
.Sp
The list returned by the \f(CW\*(C`macro\*(C'\fR method looks
similar to this:
.Sp
.Vb 7
\&  @macro = (
\&    \*(Aq_\|_STDC_VERSION_\|_ 199901L\*(Aq,
\&    \*(Aq_\|_STDC_HOSTED_\|_ 1\*(Aq,
\&    \*(AqDEFINED\*(Aq,
\&    \*(AqMULTIPLY(x, y) ((x)*(y))\*(Aq,
\&    \*(AqABC_SIZE 2\*(Aq
\&  );
.Ve
.Sp
This works only as long as the preprocessor is not reset.
See \*(L"Preprocessor configuration\*(R" for details.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
You can alternatively call the following functions as methods
on Convert::Binary::C objects.
.SS "feature"
.IX Subsection "feature"
.ie n .IP """feature"" \s-1STRING\s0" 8
.el .IP "\f(CWfeature\fR \s-1STRING\s0" 8
.IX Item "feature STRING"
Checks if Convert::Binary::C was built with certain features.
For example,
.Sp
.Vb 2
\&  print "debugging version"
\&      if Convert::Binary::C::feature(\*(Aqdebug\*(Aq);
.Ve
.Sp
will check if Convert::Binary::C was built with debugging support
enabled. The \f(CW\*(C`feature\*(C'\fR function returns \f(CW1\fR if the feature is
enabled, \f(CW0\fR if the feature is disabled, and \f(CW\*(C`undef\*(C'\fR if the
feature is unknown. Currently the only features that can be checked
are \f(CW\*(C`ieeefp\*(C'\fR and \f(CW\*(C`debug\*(C'\fR.
.Sp
You can enable or disable certain features at compile time of the
module by using the
.Sp
.Vb 1
\&  perl Makefile.PL enable\-feature disable\-feature
.Ve
.Sp
syntax.
.SS "native"
.IX Subsection "native"
.ie n .IP """native""" 8
.el .IP "\f(CWnative\fR" 8
.IX Item "native"
.PD 0
.ie n .IP """native"" \s-1STRING\s0" 8
.el .IP "\f(CWnative\fR \s-1STRING\s0" 8
.IX Item "native STRING"
.PD
Returns the value of a property of the native system that
Convert::Binary::C was built on. For example,
.Sp
.Vb 1
\&  $size = Convert::Binary::C::native(\*(AqIntSize\*(Aq);
.Ve
.Sp
will fetch the size of an \f(CW\*(C`int\*(C'\fR on the native system.
The following properties can be queried:
.Sp
.Vb 10
\&  Alignment
\&  ByteOrder
\&  CharSize
\&  CompoundAlignment
\&  DoubleSize
\&  EnumSize
\&  FloatSize
\&  HostedC
\&  IntSize
\&  LongDoubleSize
\&  LongLongSize
\&  LongSize
\&  PointerSize
\&  ShortSize
\&  StdCVersion
\&  UnsignedBitfields
\&  UnsignedChars
.Ve
.Sp
You can also call \f(CW\*(C`native\*(C'\fR without arguments,
in which case it will return a reference to a hash with all
properties, like:
.Sp
.Vb 10
\&  $native = {
\&    \*(AqStdCVersion\*(Aq => undef,
\&    \*(AqByteOrder\*(Aq => \*(AqLittleEndian\*(Aq,
\&    \*(AqLongSize\*(Aq => 4,
\&    \*(AqIntSize\*(Aq => 4,
\&    \*(AqHostedC\*(Aq => 1,
\&    \*(AqShortSize\*(Aq => 2,
\&    \*(AqUnsignedChars\*(Aq => 0,
\&    \*(AqDoubleSize\*(Aq => 8,
\&    \*(AqCharSize\*(Aq => 1,
\&    \*(AqEnumSize\*(Aq => 4,
\&    \*(AqPointerSize\*(Aq => 4,
\&    \*(AqFloatSize\*(Aq => 4,
\&    \*(AqLongLongSize\*(Aq => 8,
\&    \*(AqAlignment\*(Aq => 4,
\&    \*(AqLongDoubleSize\*(Aq => 12,
\&    \*(AqUnsignedBitfields\*(Aq => 0,
\&    \*(AqCompoundAlignment\*(Aq => 1
\&  };
.Ve
.Sp
The contents of that hash are suitable for passing them to
the \f(CW\*(C`configure\*(C'\fR method.
.SH "DEBUGGING"
.IX Header "DEBUGGING"
Like perl itself, Convert::Binary::C can be compiled with debugging
support that can then be selectively enabled at runtime. You can
specify whether you like to build Convert::Binary::C with debugging
support or not by explicitly giving an argument to \fIMakefile.PL\fR.
Use
.PP
.Vb 1
\&  perl Makefile.PL enable\-debug
.Ve
.PP
to enable debugging, or
.PP
.Vb 1
\&  perl Makefile.PL disable\-debug
.Ve
.PP
to disable debugging. The default will depend on how your perl
binary was built. If it was built with \f(CW\*(C`\-DDEBUGGING\*(C'\fR,
Convert::Binary::C will be built with debugging support, too.
.PP
Once you have built Convert::Binary::C with debugging support, you
can use the following syntax to enable debug output. Instead of
.PP
.Vb 1
\&  use Convert::Binary::C;
.Ve
.PP
you simply say
.PP
.Vb 1
\&  use Convert::Binary::C debug => \*(Aqall\*(Aq;
.Ve
.PP
which will enable all debug output. However, I don't recommend
to enable all debug output, because that can be a fairly large
amount.
.SS "Debugging options"
.IX Subsection "Debugging options"
Instead of saying \f(CW\*(C`all\*(C'\fR, you can pass a string that
consists of one or more of the following characters:
.PP
.Vb 2
\&  m   enable memory allocation tracing
\&  M   enable memory allocation & assertion tracing
\&  
\&  h   enable hash table debugging
\&  H   enable hash table dumps
\&  
\&  d   enable debug output from the XS module
\&  c   enable debug output from the ctlib
\&  t   enable debug output about type objects
\&  
\&  l   enable debug output from the C lexer
\&  p   enable debug output from the C parser
\&  P   enable debug output from the C preprocessor
\&  r   enable debug output from the #pragma parser
\&  
\&  y   enable debug output from yacc (bison)
.Ve
.PP
So the following might give you a brief overview of what's
going on inside Convert::Binary::C:
.PP
.Vb 1
\&  use Convert::Binary::C debug => \*(Aqdct\*(Aq;
.Ve
.PP
When you want to debug memory allocation using
.PP
.Vb 1
\&  use Convert::Binary::C debug => \*(Aqm\*(Aq;
.Ve
.PP
you can use the Perl script \fIcheck_alloc.pl\fR that resides
in the \fIctlib/util/tool\fR directory to extract statistics
about memory usage and information about memory leaks from
the resulting debug output.
.SS "Redirecting debug output"
.IX Subsection "Redirecting debug output"
By default, all debug output is written to \f(CW\*(C`stderr\*(C'\fR. You
can, however, redirect the debug output to a file with
the \f(CW\*(C`debugfile\*(C'\fR option:
.PP
.Vb 2
\&  use Convert::Binary::C debug     => \*(AqdcthHm\*(Aq,
\&                         debugfile => \*(Aq./debug.out\*(Aq;
.Ve
.PP
If the file cannot be opened, you'll receive a warning and
the output will go the \f(CW\*(C`stderr\*(C'\fR way again.
.PP
Alternatively, you can use the environment
variables \f(CW\*(C`CBC_DEBUG_OPT\*(C'\fR and \f(CW\*(C`CBC_DEBUG_FILE\*(C'\fR to
turn on debug output.
.PP
If Convert::Binary::C is built without debugging support,
passing the \f(CW\*(C`debug\*(C'\fR or \f(CW\*(C`debugfile\*(C'\fR options will cause
a warning to be issued. The corresponding environment
variables will simply be ignored.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.ie n .SS """CBC_ORDER_MEMBERS"""
.el .SS "\f(CWCBC_ORDER_MEMBERS\fP"
.IX Subsection "CBC_ORDER_MEMBERS"
Setting this variable to a non-zero value will globally
turn on hash key ordering for compound members. Have a
look at the \f(CW\*(C`OrderMembers\*(C'\fR option for details.
.PP
Setting the variable to the name of a perl module will
additionally use this module instead of the predefined
modules for member ordering to tie the hashes to.
.ie n .SS """CBC_DEBUG_OPT"""
.el .SS "\f(CWCBC_DEBUG_OPT\fP"
.IX Subsection "CBC_DEBUG_OPT"
If Convert::Binary::C is built with debugging
support, you can use this variable to specify
the debugging options.
.ie n .SS """CBC_DEBUG_FILE"""
.el .SS "\f(CWCBC_DEBUG_FILE\fP"
.IX Subsection "CBC_DEBUG_FILE"
If Convert::Binary::C is built with debugging support,
you can use this variable to redirect the
debug output to a file.
.ie n .SS """CBC_DISABLE_PARSER"""
.el .SS "\f(CWCBC_DISABLE_PARSER\fP"
.IX Subsection "CBC_DISABLE_PARSER"
This variable is intended purely for development. Setting
it to a non-zero value disables the Convert::Binary::C parser,
which means that no information is collected from the file
or code that is parsed. However, the preprocessor will run,
which is useful for benchmarking the preprocessor.
.SH "FLEXIBLE ARRAY MEMBERS AND INCOMPLETE TYPES"
.IX Header "FLEXIBLE ARRAY MEMBERS AND INCOMPLETE TYPES"
Flexible array members are a feature introduced with \s-1ISO\-C99.\s0
It's a common problem that you have a variable length data
field at the end of a structure, for example an array of
characters at the end of a message struct. \s-1ISO\-C99\s0 allows
you to write this as:
.PP
.Vb 4
\&  struct message {
\&    long header;
\&    char data[];
\&  };
.Ve
.PP
The advantage is that you clearly indicate that the size
of the appended data is variable, and that the \f(CW\*(C`data\*(C'\fR member
doesn't contribute to the size of the \f(CW\*(C`message\*(C'\fR structure.
.PP
When packing or unpacking data, Convert::Binary::C deals with
flexible array members as if their length was adjustable. For
example, \f(CW\*(C`unpack\*(C'\fR will adapt the length of the
array depending on the input string:
.PP
.Vb 2
\&  $msg1 = $c\->unpack(\*(Aqmessage\*(Aq, \*(Aqabcdefg\*(Aq);
\&  $msg2 = $c\->unpack(\*(Aqmessage\*(Aq, \*(Aqabcdefghijkl\*(Aq);
.Ve
.PP
The following data is unpacked:
.PP
.Vb 10
\&  $msg1 = {
\&    \*(Aqdata\*(Aq => [
\&      101,
\&      102,
\&      103
\&    ],
\&    \*(Aqheader\*(Aq => 1633837924
\&  };
\&  $msg2 = {
\&    \*(Aqdata\*(Aq => [
\&      101,
\&      102,
\&      103,
\&      104,
\&      105,
\&      106,
\&      107,
\&      108
\&    ],
\&    \*(Aqheader\*(Aq => 1633837924
\&  };
.Ve
.PP
Similarly, pack will adjust the length of the output string
according to the data you feed in:
.PP
.Vb 1
\&  use Data::Hexdumper;
\&  
\&  $msg = {
\&    header => 4711,
\&    data   => [0x10, 0x20, 0x30, 0x40, 0x77..0x88],
\&  };
\&  
\&  $data = $c\->pack(\*(Aqmessage\*(Aq, $msg);
\&  
\&  print hexdump(data => $data);
.Ve
.PP
This would print:
.PP
.Vb 2
\&    0x0000 : 00 00 12 67 10 20 30 40 77 78 79 7A 7B 7C 7D 7E : ...g..0@wxyz{|}~
\&    0x0010 : 7F 80 81 82 83 84 85 86 87 88                   : ..........
.Ve
.PP
Incomplete types such as
.PP
.Vb 1
\&  typedef unsigned long array[];
.Ve
.PP
are handled in exactly the same way. Thus, you can easily
.PP
.Vb 1
\&  $array = $c\->unpack(\*(Aqarray\*(Aq, \*(Aq?\*(Aqx20);
.Ve
.PP
which will unpack the following array:
.PP
.Vb 7
\&  $array = [
\&    1061109567,
\&    1061109567,
\&    1061109567,
\&    1061109567,
\&    1061109567
\&  ];
.Ve
.PP
You can also alter the length of an array using
the \f(CW\*(C`Dimension\*(C'\fR tag.
.SH "FLOATING POINT VALUES"
.IX Header "FLOATING POINT VALUES"
When using Convert::Binary::C to handle floating point values,
you have to be aware of some limitations.
.PP
You're usually safe if all your platforms are using the \s-1IEEE\s0
floating point format. During the Convert::Binary::C build
process, the \f(CW\*(C`ieeefp\*(C'\fR feature will automatically be enabled
if the host is using \s-1IEEE\s0 floating point. You can check for
this feature at runtime using
the \f(CW\*(C`feature\*(C'\fR function:
.PP
.Vb 3
\&  if (Convert::Binary::C::feature(\*(Aqieeefp\*(Aq)) {
\&    # do something
\&  }
.Ve
.PP
When \s-1IEEE\s0 floating point support is enabled, the module can
also handle floating point values of a different byteorder.
.PP
If your host platform is not using \s-1IEEE\s0 floating point,
the \f(CW\*(C`ieeefp\*(C'\fR feature will be disabled. Convert::Binary::C
then will be more restrictive, refusing to handle any
non-native floating point values.
.PP
However, Convert::Binary::C cannot detect the floating point
format used by your target platform. It can only try to
prevent problems in obvious cases. If you know your target
platform has a completely different floating point format,
don't use floating point conversion at all.
.PP
Whenever Convert::Binary::C detects that it cannot properly
do floating point value conversion, it will issue a warning
and will not attempt to convert the floating point value.
.SH "BITFIELDS"
.IX Header "BITFIELDS"
Bitfield support in Convert::Binary::C is currently in an
\&\fBexperimental\fR state. You are encouraged to test it, but you
should not blindly rely on its results.
.PP
You are also encouraged to supply layouting algorithms for
compilers whose bitfield implementation is not handled
correctly at the moment. Even better that the plain algorithm
is of course a patch that adds a new bitfield layouting
engine.
.PP
While bitfields may not be handled correctly by the conversion
routines yet, they are always parsed correctly. This means
that you can reliably use the declarator fields as returned
by the \f(CW\*(C`struct\*(C'\fR or \f(CW\*(C`typedef\*(C'\fR methods.
Given the following source
.PP
.Vb 6
\&  struct bitfield {
\&    int seven:7;
\&    int :1;
\&    int four:4, :0;
\&    int integer;
\&  };
.Ve
.PP
a call to \f(CW\*(C`struct\*(C'\fR will return
.PP
.Vb 10
\&  @struct = (
\&    {
\&      \*(Aqidentifier\*(Aq => \*(Aqbitfield\*(Aq,
\&      \*(Aqalign\*(Aq => 1,
\&      \*(Aqcontext\*(Aq => \*(Aqbitfields.c(1)\*(Aq,
\&      \*(Aqpack\*(Aq => 0,
\&      \*(Aqtype\*(Aq => \*(Aqstruct\*(Aq,
\&      \*(Aqdeclarations\*(Aq => [
\&        {
\&          \*(Aqdeclarators\*(Aq => [
\&            {
\&              \*(Aqdeclarator\*(Aq => \*(Aqseven:7\*(Aq
\&            }
\&          ],
\&          \*(Aqtype\*(Aq => \*(Aqint\*(Aq
\&        },
\&        {
\&          \*(Aqdeclarators\*(Aq => [
\&            {
\&              \*(Aqdeclarator\*(Aq => \*(Aq:1\*(Aq
\&            }
\&          ],
\&          \*(Aqtype\*(Aq => \*(Aqint\*(Aq
\&        },
\&        {
\&          \*(Aqdeclarators\*(Aq => [
\&            {
\&              \*(Aqdeclarator\*(Aq => \*(Aqfour:4\*(Aq
\&            },
\&            {
\&              \*(Aqdeclarator\*(Aq => \*(Aq:0\*(Aq
\&            }
\&          ],
\&          \*(Aqtype\*(Aq => \*(Aqint\*(Aq
\&        },
\&        {
\&          \*(Aqdeclarators\*(Aq => [
\&            {
\&              \*(Aqdeclarator\*(Aq => \*(Aqinteger\*(Aq,
\&              \*(Aqsize\*(Aq => 4,
\&              \*(Aqoffset\*(Aq => 4
\&            }
\&          ],
\&          \*(Aqtype\*(Aq => \*(Aqint\*(Aq
\&        }
\&      ],
\&      \*(Aqsize\*(Aq => 8
\&    }
\&  );
.Ve
.PP
No size/offset keys will currently be returned for bitfield
entries.
.SH "MULTITHREADING"
.IX Header "MULTITHREADING"
Convert::Binary::C was designed to be thread-safe.
.SH "INHERITANCE"
.IX Header "INHERITANCE"
If you wish to derive a new class from Convert::Binary::C,
this is relatively easy. Despite their \s-1XS\s0 implementation,
Convert::Binary::C objects are actually blessed hash
references.
.PP
The \s-1XS\s0 data is stored in a read-only hash value for the
key that is the empty string. So it is safe to use any
non-empty hash key when deriving your own class.
In addition, Convert::Binary::C does quite a lot of checks
to detect corruption in the object hash.
.PP
If you store private data in the hash, you should override
the \f(CW\*(C`clone\*(C'\fR method and provide the necessary code to clone
your private data. You'll have to call \f(CW\*(C`SUPER::clone\*(C'\fR, but
this will only clone the Convert::Binary::C part of the object.
.PP
For an example of a derived class, you can have a look at
Convert::Binary::C::Cached.
.SH "PORTABILITY"
.IX Header "PORTABILITY"
Convert::Binary::C should build and run on most of the
platforms that Perl runs on:
.IP "\(bu" 4
Various Linux systems
.IP "\(bu" 4
Various \s-1BSD\s0 systems
.IP "\(bu" 4
HP-UX
.IP "\(bu" 4
Compaq/HP Tru64 Unix
.IP "\(bu" 4
Mac-OS X
.IP "\(bu" 4
Cygwin
.IP "\(bu" 4
Windows 98/NT/2000/XP
.PP
Also, many architectures are supported:
.IP "\(bu" 4
Various Intel Pentium and Itanium systems
.IP "\(bu" 4
Various Alpha systems
.IP "\(bu" 4
\&\s-1HP\s0 PA-RISC
.IP "\(bu" 4
Power-PC
.IP "\(bu" 4
StrongARM
.PP
The module should build with any perl binary from 5.004
up to the latest development version.
.SH "COMPARISON WITH SIMILAR MODULES"
.IX Header "COMPARISON WITH SIMILAR MODULES"
Most of the time when you're really looking for
Convert::Binary::C you'll actually end up finding
one of the following modules. Some of them have
different goals, so it's probably worth pointing
out the differences.
.SS "C::Include"
.IX Subsection "C::Include"
Like Convert::Binary::C, this module aims at doing
conversion from and to binary data based on C types.
However, its configurability is very limited compared
to Convert::Binary::C. Also, it does not parse all C
code correctly. It's slower than Convert::Binary::C,
doesn't have a preprocessor. On the plus side, it's
written in pure Perl.
.SS "C::DynaLib::Struct"
.IX Subsection "C::DynaLib::Struct"
This module doesn't allow you to reuse your C source
code. One main goal of Convert::Binary::C was to avoid
code duplication or, even worse, having to maintain
different representations of your data structures.
Like C::Include, C::DynaLib::Struct is rather limited
in its configurability.
.SS "Win32::API::Struct"
.IX Subsection "Win32::API::Struct"
This module has a special purpose. It aims at building
structs for interfacing Perl code with Windows \s-1API\s0 code.
.SH "CREDITS"
.IX Header "CREDITS"
.IP "\(bu" 2
My love Jennifer for always being there, for filling my life with
joy and last but not least for proofreading the documentation.
.IP "\(bu" 2
Alain Barbet <alian@cpan.org> for testing and debugging
support.
.IP "\(bu" 2
Mitchell N. Charity for giving me pointers into various
interesting directions.
.IP "\(bu" 2
Alexis Denis for making me improve (externally) and simplify
(internally) floating point support. He can also be blamed
(indirectly) for the \f(CW\*(C`initializer\*(C'\fR method,
as I need it in my effort to support bitfields some day.
.IP "\(bu" 2
Michael J. Hohmann <mjh@scientist.de> for endless discussions
on our way to and back home from work, and for making me think
about supporting \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR for
compound members.
.IP "\(bu" 2
Thorsten Jens <thojens@gmx.de> for testing the package
on various platforms.
.IP "\(bu" 2
Mark Overmeer <mark@overmeer.net> for suggesting the
module name and giving invaluable feedback.
.IP "\(bu" 2
Thomas Pornin <pornin@bolet.org> for his
excellent \f(CW\*(C`ucpp\*(C'\fR preprocessor library.
.IP "\(bu" 2
Marc Rosenthal for his suggestions and support.
.IP "\(bu" 2
James Roskind, as his C parser was a great starting point to fix
all the problems I had with my original parser based only on the
\&\s-1ANSI\s0 ruleset.
.IP "\(bu" 2
Gisbert W. Selke for spotting some interesting bugs and providing
extensive reports.
.IP "\(bu" 2
Steffen Zimmermann for a prolific discussion on the cloning
algorithm.
.SH "MAILING LIST"
.IX Header "MAILING LIST"
There's also a mailing list that you can join:
.PP
.Vb 1
\&  convert\-binary\-c@yahoogroups.com
.Ve
.PP
To subscribe, simply send mail to:
.PP
.Vb 1
\&  convert\-binary\-c\-subscribe@yahoogroups.com
.Ve
.PP
You can use this mailing list for non-bug problems, questions
or discussions.
.SH "BUGS"
.IX Header "BUGS"
I'm sure there are still lots of bugs in the code for this
module. If you find any bugs, Convert::Binary::C doesn't
seem to build on your system or any of its tests fail, please
use the \s-1CPAN\s0 Request Tracker at <http://rt.cpan.org/> to
create a ticket for the module. Alternatively, just send a
mail to <mhx@cpan.org>.
.SH "EXPERIMENTAL FEATURES"
.IX Header "EXPERIMENTAL FEATURES"
Some features in Convert::Binary::C are marked as experimental.
This has most probably one of the following reasons:
.IP "\(bu" 2
The feature does not behave in exactly the way that I wish
it did, possibly due to some limitations in the current
design of the module.
.IP "\(bu" 2
The feature hasn't been tested enough and may completely
fail to produce the expected results.
.PP
I hope to fix most issues with these experimental features
someday, but this may mean that I have to change the way
they currently work in a way that's not backwards compatible.
So if any of these features is useful to you, you can use
it, but you should be aware that the behaviour or the
interface may change in future releases of this module.
.SH "TODO"
.IX Header "TODO"
If you're interested in what I currently plan to improve
(or fix), have a look at the \fI\s-1TODO\s0\fR file.
.SH "POSTCARDS"
.IX Header "POSTCARDS"
If you're using my module and like it, you can show your appreciation
by sending me a postcard from where you live. I won't urge you to do it,
it's completely up to you. To me, this is just a very nice way of
receiving feedback about my work. Please send your postcard to:
.PP
.Vb 4
\&  Marcus Holland\-Moritz
\&  Kuppinger Weg 28
\&  71116 Gaertringen
\&  GERMANY
.Ve
.PP
If you feel that sending a postcard is too much effort, you maybe
want to rate the module at <http://cpanratings.perl.org/>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2015 Marcus Holland-Moritz. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.PP
The \f(CW\*(C`ucpp\*(C'\fR library is (c) 1998\-2002 Thomas Pornin. For license
and redistribution details refer to \fIctlib/ucpp/README\fR.
.PP
Portions copyright (c) 1989, 1990 James A. Roskind.
.PP
The include files located in \fItests/include/include\fR, which are used
in some of the test scripts are (c) 1991\-1999, 2000, 2001 Free Software
Foundation, Inc. They are neither required to create the binary nor
linked to the source code of this module in any other way.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See ccconfig, perl, perldata, perlop, perlvar, Data::Dumper and Scalar::Util.
