--- /dev/null	2014-02-09 17:04:39.020342584 +0800
+++ iptables-1.4.16.3/extensions/libipt_TRIGGER.c	2014-03-05 11:18:50.689007004 +0800
@@ -0,0 +1,306 @@
+/* Port-triggering target. 
+ *
+ * Copyright (C) 2003, CyberTAN Corporation
+ * All Rights Reserved.
+ */
+
+/* Shared library add-on to iptables to add port-trigger support. */
+
+/*2012-08-02: Zhijian modify for multiple port range*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_TRIGGER.h>
+#include <net/netfilter/nf_nat.h>
+
+enum {
+	O_TYPE = 0,
+	O_PROTO,
+	O_MATCH,
+	O_RELATE,
+};
+
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"TRIGGER v%s options:\n"
+" --trigger-type (dnat|in|out)\n"
+"				Trigger type\n"
+" --trigger-proto proto\n"
+"				Trigger protocol\n"
+" --trigger-match port[-port]\n"
+"				Trigger destination port range\n"
+" --trigger-relate port[-port]\n"
+"				Port range to map related destination port range to.\n\n",
+IPTABLES_VERSION);
+}
+
+static struct xt_option_entry TRIGGER_opts[] = {
+	{ .name = "trigger-type", .id = O_TYPE, .type = XTTYPE_STRING},
+	{ .name = "trigger-proto", .id = O_PROTO, .type = XTTYPE_STRING},
+	{ .name = "trigger-match", .id = O_MATCH, .type = XTTYPE_STRING},
+	{ .name = "trigger-relate", .id = O_RELATE, .type = XTTYPE_STRING},
+	XTOPT_TABLEEND,
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t)
+{
+	//struct ipt_trigger_info *tg = (struct ipt_trigger_info *)t->data;
+}
+
+/* Parses ports */
+static void
+parse_ports(const char *arg, u_int16_t *ports)
+{
+	//const char *dash;
+	char *end;
+	unsigned int port, maxport;
+
+	if (!xtables_strtoui(arg, &end, &port, 0, UINT16_MAX))
+		xtables_error(PARAMETER_PROBLEM, "Port range `%s' invalid\n", arg);
+	//port = atoi(arg);
+	//if (port == 0 || port > 65535)
+	//	xtables_error(PARAMETER_PROBLEM, "Port range `%s' invalid\n", arg);
+
+
+	switch (*end) {
+	case '\0':
+		ports[0] = ports[1] = port;
+		return;
+	case ':':
+	case '-':
+		if (!xtables_strtoui(end + 1, NULL, &maxport, 0, UINT16_MAX))
+			break;
+
+		if (maxport < port)
+			break;
+
+		ports[0] = port;
+		ports[1] = maxport;
+		return;
+	default:
+		break;
+	}
+	xtables_error(PARAMETER_PROBLEM,
+			"Port range `%s' invalid\n", arg);
+}
+
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static void 
+parse(struct xt_option_call *cb)
+{
+	struct ipt_trigger_info *info = (struct ipt_trigger_info *)cb->data;
+	const char *arg;
+	char *comma;
+	int i;
+
+	xtables_option_parse(cb);
+	switch (cb->entry->id) {
+	case O_TYPE:
+		if (!strcasecmp(cb->arg, "dnat"))
+			info->type = IPT_TRIGGER_DNAT;
+		else if (!strcasecmp(cb->arg, "in"))
+			info->type = IPT_TRIGGER_IN;
+		else if (!strcasecmp(cb->arg, "out"))
+			info->type = IPT_TRIGGER_OUT;
+		else
+			xtables_error(PARAMETER_PROBLEM,
+				   "unknown type `%s' specified", cb->arg);
+		return;
+
+	case O_PROTO:
+		for(arg = cb->arg, i = 0; arg && *arg && i < MAX_TRIG_RANGE; arg = comma, i ++)
+		{
+			comma = strchr(arg, ',');
+			if(comma)
+			{
+				*comma = '\0';
+				comma ++;
+			}
+			if (!strcasecmp(arg, "tcp"))
+				info->proto[i] = IPPROTO_TCP;
+			else if (!strcasecmp(arg, "udp"))
+				info->proto[i] = IPPROTO_UDP;
+			else if (!strcasecmp(arg, "all"))
+				info->proto[i] = 0;
+			else
+				xtables_error(PARAMETER_PROBLEM,
+					   "unknown protocol `%s' specified", arg);
+		}
+		return;
+
+	case O_MATCH:
+		parse_ports(cb->arg, info->mport);
+		return;
+
+	case O_RELATE:
+
+		for(arg = cb->arg, i = 0; arg && *arg && i < MAX_TRIG_RANGE; arg = comma, i ++)
+		{
+			comma = strchr(arg, ',');
+			if(comma)
+			{
+				*comma = '\0';
+				comma ++;
+			}
+			parse_ports(arg, info->rport[i]);
+		}
+		//*flags |= IP_NAT_RANGE_PROTO_SPECIFIED;
+		return;
+
+	default:
+		return;
+	}
+}
+
+/* Final check; don't care. */
+static void final_check(struct xt_fcheck_call *cb)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const void *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	struct ipt_trigger_info *info = (struct ipt_trigger_info *)target->data;
+	int i;
+
+	printf("TRIGGER ");
+	if (info->type == IPT_TRIGGER_DNAT)
+		printf("type:dnat ");
+	else if (info->type == IPT_TRIGGER_IN)
+		printf("type:in ");
+	else if (info->type == IPT_TRIGGER_OUT)
+		printf("type:out ");
+
+	for(i = 0; i < MAX_TRIG_RANGE; i ++)
+	{
+		if(i > 0)
+		{
+			printf(",");
+		}
+		if (info->proto[i] == IPPROTO_TCP)
+			printf("tcp");
+		else if (info->proto[i] == IPPROTO_UDP)
+			printf("udp");
+		else
+			printf("all");
+	}
+	printf(" ");
+
+	if(info->mport[0] > 0)
+	{
+	printf("match:%hu", info->mport[0]);
+	if (info->mport[1] > info->mport[0])
+		printf("-%hu", info->mport[1]);
+	printf(" ");
+
+	printf("relate:");
+	for(i = 0; i < MAX_TRIG_RANGE; i ++)
+	{
+		if(info->rport[i][0] == 0)
+		{
+			break;
+		}
+		if(i > 0)
+		{
+			printf(",");
+		}
+		printf("%hu", info->rport[i][0]);
+		if (info->rport[i][1] > info->rport[i][0])
+			printf("-%hu", info->rport[i][1]);
+	}
+	printf(" ");
+	}
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const void *ip, const struct ipt_entry_target *target)
+{
+	struct ipt_trigger_info *info = (struct ipt_trigger_info *)target->data;
+	int i;
+
+	if (info->type == IPT_TRIGGER_DNAT)
+		printf("--trigger-type dnat ");
+	else if (info->type == IPT_TRIGGER_IN)
+		printf("--trigger-type in ");
+	else if (info->type == IPT_TRIGGER_OUT)
+		printf("--trigger-type out ");
+
+	printf("--trigger-proto ");
+	for(i = 0; i < MAX_TRIG_RANGE; i ++)
+	{
+		if(i > 0)
+		{
+			printf(",");
+		}
+		if (info->proto[i] == IPPROTO_TCP)
+			printf("tcp");
+		else if (info->proto[i] == IPPROTO_UDP)
+			printf("udp");
+		else
+			printf("all");
+	}
+	printf(" ");
+	
+	if(info->mport[0] > 0)
+	{
+	printf("--trigger-match %hu", info->mport[0]);
+	if (info->mport[1] > info->mport[0])
+		printf("-%hu", info->mport[1]);
+	printf(" ");
+	
+	printf("--trigger-relate ");
+	for(i = 0; i < MAX_TRIG_RANGE; i ++)
+	{
+		if(info->rport[i][0] == 0)
+		{
+			break;
+		}
+		if(i > 0)
+		{
+			printf(",");
+		}
+		printf("%hu", info->rport[i][0]);
+		if (info->rport[i][1] > info->rport[i][0])
+			printf("-%hu", info->rport[i][1]);
+	}
+	printf(" ");
+	}
+}
+
+static
+struct xtables_target trigger = {
+    	.name		=	"TRIGGER",
+ 	.version       	= 	XTABLES_VERSION,
+        .family        	=	NFPROTO_IPV4,
+	.size		=	XT_ALIGN(sizeof(struct ipt_trigger_info)),
+    	.userspacesize	=	XT_ALIGN(sizeof(struct ipt_trigger_info)),
+    	.help		=	&help,
+	.init		= 	&init,
+    	.x6_parse	=	&parse,
+    	.x6_fcheck	=	&final_check,
+    	.print		=	&print,
+    	.save		=	&save,
+    	.x6_options	=	TRIGGER_opts
+};
+
+void _init(void)
+{
+	xtables_register_target(&trigger);
+}
