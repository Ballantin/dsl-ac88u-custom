--- a/pppd/lcp.c	2017-04-12 11:41:40.366154700 +0800
+++ b/pppd/lcp.c	2017-04-12 13:24:06.368998782 +0800
@@ -49,6 +49,12 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+/***********************************************/
+#include <sys/sysinfo.h>
+#include <time.h>
+#include <sys/types.h>
+#include <unistd.h>
+/***********************************************/
 
 #include "pppd.h"
 #include "fsm.h"
@@ -61,6 +67,15 @@
 extern bool refuse_pap;
 extern bool refuse_chap;
 #endif
+//copy from pppoe Code_Sung 2017/2/23
+#define cprintf(fmt, args...) do { \
+        FILE *fp = fopen("/dev/console", "w"); \
+        if (fp) { \
+                fprintf(fp, fmt, ## args); \
+                fclose(fp); \
+        } \
+} while (0)
+//copy from pppoe end Code_Sung 2017/2/23
 
 static const char rcsid[] = RCSID;
 
@@ -77,14 +92,22 @@
 /*
  * LCP-related command-line options.
  */
-int	lcp_echo_interval = 0; 	/* Interval between LCP echo-requests */
-int	lcp_echo_fails = 0;	/* Tolerance to unanswered echo-requests */
-bool	lcp_echo_adaptive = 0;	/* request echo only if the link was idle */
-bool	lax_recv = 0;		/* accept control chars in asyncmap */
-bool	noendpoint = 0;		/* don't send/accept endpoint discriminator */
+int		lcp_echo_interval = 30;		/* Interval between LCP echo-requests */
+int		lcp_echo_fails = 5;			/* Tolerance to unanswered echo-requests */
+bool	lcp_echo_adaptive = 0;		/* request echo only if the link was idle */
+bool	lax_recv = 0;				/* accept control chars in asyncmap */
+bool	noendpoint = 0;				/* don't send/accept endpoint discriminator */
 
 static int noopt __P((char **));
-
+//copy from pppoe Code_Sung 2017/3/23 
+/***********************************************/
+static time_t echo_time = 0;
+#ifdef TIMEOUT_WARNING
+extern time_t ip_up_time;
+extern int check_timeout(int flag);
+#endif
+/***********************************************/
+//copy from pppoe end Code_Sung 2017/3/23 
 #ifdef HAVE_MULTILINK
 static int setendpoint __P((char **));
 static void printendpoint __P((option_t *, void (*)(void *, char *, ...),
@@ -302,6 +325,18 @@
 #define CODENAME(x)	((x) == CONFACK ? "ACK" : \
 			 (x) == CONFNAK ? "NAK" : "REJ")
 
+//copy from pppoe Code_Sung 2017/3/23 
+/***********************************************/
+time_t get_time(void)
+{
+	struct sysinfo info;
+ 
+	sysinfo(&info);
+ 
+	return info.uptime;
+}
+/***********************************************/
+//copy from pppoe end Code_Sung 2017/3/23 
 /*
  * noopt - Disable all options (why?).
  */
@@ -574,10 +609,27 @@
 	magp = inp;
 	PUTLONG(lcp_gotoptions[f->unit].magicnumber, magp);
 	fsm_sdata(f, ECHOREP, id, inp, len);
+	
+	// copy from pppoe Code_Sung 2017/3/23
+	/***********************************************/
+	/* Reset the number of outstanding echo frames */
+	lcp_echos_pending = 0;
+	cprintf("LCP: Receive LCP ECHO Request\n");
+	echo_time = get_time();
+	/***********************************************/
+	// copy from pppoe end Code_Sung 2017/3/23
+	
 	break;
     
     case ECHOREP:
 	lcp_received_echo_reply(f, id, inp, len);
+	
+	// copy from pppoe Code_Sung 2017/3/23
+	/***********************************************/
+	cprintf("LCP: Receive LCP ECHO Reply\n");
+	/***********************************************/
+	// copy from pppoe end Code_Sung 2017/3/23
+	
 	break;
 
     case DISCREQ:
@@ -2003,6 +2055,12 @@
 		    (go->neg_asyncmap? go->asyncmap: 0xffffffff),
 		    go->neg_pcompression, go->neg_accompression);
     peer_mru[f->unit] = PPP_MRU;
+	
+	// copy from pppoe Code_Sung 2017/3/23
+	/***********************************************/
+	cprintf("LCP: Down, the last receiving LCP Echo Request is %lds ago.\n", get_time() - echo_time);
+	/***********************************************/
+	// copy from pppoe end Code_Sung 2017/3/23
 }
 
 
@@ -2025,6 +2083,12 @@
     fsm *f;
 {
     link_terminated(f->unit);
+	// copy from pppoe Code_Sung 2017/3/23
+	/***********************************************/
+	cprintf("LCP: Finish\n");
+	system("arc_syslogc dial \"PPPoa LCP: Finish.\"");
+	/***********************************************/
+	// copy from pppoe end Code_Sung 2017/3/23
 }
 
 
@@ -2308,6 +2372,7 @@
     /*
      * Start the timer for the next interval.
      */
+	
     if (lcp_echo_timer_running)
 	warn("assertion lcp_echo_timer_running==0 failed");
     TIMEOUT (LcpEchoTimeout, f, lcp_echo_interval);
@@ -2367,15 +2432,47 @@
 {
     u_int32_t lcp_magic;
     u_char pkt[4], *pktp;
-
+	
+	// copy from pppoecd Code_Sung 2017/3/23
+	/***********************************************/
+	struct ppp_idle idle;
+	unsigned long echo_interval;
+
+	echo_interval = get_time() - echo_time;
+	if(echo_interval <= lcp_echo_interval)
+	{
+		cprintf("LCP: Already receive LCP Echo Request in %ds, ignore sending it again.\n", lcp_echo_interval);
+		return;
+	}
+	
+	cprintf("LCP: The last receiving LCP Echo Request time is %lds ago.\n", echo_interval);
+	/***********************************************/
+	// copy from pppoecd end Code_Sung 2017/3/23
+	
     /*
      * Detect the failure of the peer at this point.
      */
     if (lcp_echo_fails != 0) {
         if (lcp_echos_pending >= lcp_echo_fails) {
-            LcpLinkFailure(f);
-	    lcp_echos_pending = 0;
-	}
+	
+			// copy from pppoecd Code_Sung 2017/3/23
+			/***********************************************/
+			if (get_idle_time(0, &idle))
+			{
+				cprintf("LCP: PPPoA idle receive time = %ld.\n", idle.recv_idle);
+				if(idle.recv_idle < lcp_echo_fails * lcp_echo_interval)
+				{
+					lcp_echos_pending--;
+					goto SendEchoRequest;
+				}
+			}	
+			cprintf("LCP: Check Echo Reply Fails, lcp_echos_pending = %d\n", lcp_echos_pending);
+			/***********************************************/
+			// copy from pppoecd end Code_Sung 2017/3/23
+	
+			LcpLinkFailure(f);
+			lcp_echos_pending = 0;
+		}
     }
 
     /*
@@ -2383,26 +2480,28 @@
      * no traffic was received since the last one.
      */
     if (lcp_echo_adaptive) {
-	static unsigned int last_pkts_in = 0;
+		static unsigned int last_pkts_in = 0;
 
-	update_link_stats(f->unit);
-	link_stats_valid = 0;
+		update_link_stats(f->unit);
+		link_stats_valid = 0;
 
-	if (link_stats.pkts_in != last_pkts_in) {
-	    last_pkts_in = link_stats.pkts_in;
-	    return;
-	}
+		if (link_stats.pkts_in != last_pkts_in) {
+	    	last_pkts_in = link_stats.pkts_in;
+	   		return;
+		}
     }
-
+/***********************************************/
+SendEchoRequest:
+/***********************************************/
     /*
      * Make and send the echo request frame.
      */
     if (f->state == OPENED) {
         lcp_magic = lcp_gotoptions[f->unit].magicnumber;
-	pktp = pkt;
-	PUTLONG(lcp_magic, pktp);
+		pktp = pkt;
+		PUTLONG(lcp_magic, pktp);
         fsm_sdata(f, ECHOREQ, lcp_echo_number++ & 0xFF, pkt, pktp - pkt);
-	++lcp_echos_pending;
+		++lcp_echos_pending;
     }
 }
 
@@ -2422,10 +2521,10 @@
     lcp_echo_timer_running = 0;
   
     /* If a timeout interval is specified then start the timer */
-    if (lcp_echo_interval != 0)
+    if (lcp_echo_interval != 0){
         LcpEchoCheck (f);
+	}
 }
-
 /*
  * lcp_echo_lowerdown - Stop the timer for the LCP frame
  */
